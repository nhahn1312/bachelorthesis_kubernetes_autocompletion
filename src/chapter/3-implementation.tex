\chapter{Implementierung}\label{ch:implementation}

Um die in Kapitel~\ref{ch:introduction} gestellten Forschungsfragen zu beantworten, wurde ein \ac{lsp}-Server und ein \ac{lsp}-Client entwickelt,
welche die Autovervollständigung und Validierung von Kubernetes \textit{Manifest}-Dateien ermöglichen.
Die beiden Komponenten wurden als installierbare Erweiterung für den Quellcode-Editor \ac{vscode} bereitgestellt.

\section{Technologien}

\begin{description}
      \item[NodeJS]
            Bei \textit{NodeJS} handelt es sich um eine plattformübergreifende Laufzeitumgebung, mit welcher Javascript-Programme entwickelt werden können,
            die unabhängig von Host-Anwendungen, wie \ac{zB} dem Webbrowser laufen.
            Das Konzept des ``non-blocking I/O'' wird von \textit{NodeJS} für die parallele und asynchrone Ausführung von Code verwendet.
            Programme müssen dabei nicht auf die Ergebnisse einer Ein-/Ausgabe-Funktion warten,
            sondern werden über ein Ereignis über die Beendigung informiert.
            \textit{NodeJS} lässt sich mit Modulen erweitern.
            Der sogenannte \ac{npm} unterstützt den Entwickler dabei und kann Module sowie deren Abhängigkeiten suchen,
            installieren, entfernen und aktualisieren.~\cite{node-js-dev-insider,node-js-about}.
            Im Rahmen des Projektes wurden mit Hilfe von NodeJS der \ac{lsp}-Client und \ac{lsp}-Server implementiert.
      \item[Typescript]
            \textit{Typescript} ist eine Skriptsprache, die eine syntaktische Obermenge von Javascript ist. Das heißt, dass \textit{Typescript} und Javascript
            die gleiche Syntax besitzen, Typescript jedoch noch über zusätzliche Syntax verfügt.
            \textit{Typescript} erlaubt dem Programmierer \ac{zB} die statische Typisierung von Variablen, Funktionsparametern und Rückgabetypen.
            Die Code-Qualität kann dadurch erhöht werden. Ein Compiler übersetzt \textit{Typescript}-Code in lauffähigen Javascript-Code, welcher dann von einer
            wie \ac{zB} \textit{NodeJS} ausgeführt werden kann~\cite{typescript-kinsta,typescript-doubleslash-blog}.
            Der \ac{lsp}-Client und \ac{lsp}-Server wurden mit der Skriptsprache \textit{Typescript} entwickelt.
      \item[Docker for Desktop]
            Mit \textit{Docker for Desktop} lassen sich Anwendungen in \textit{Containern} zusammenstellen, teilen und ausführen.
            Das Programm ist für Mac, Linux und Windows Umgebungen verfügbar und bietet ein \ac{gui} zur Verwaltung der \textit{Container} an~\cite{docker-for-desktop-overview}.
            \textit{Docker for Desktop} enthält außerdem ein Kubernetes-Cluster, welches lokal auf einem einzigen \textit{Node} ausgeführt wird~\cite{docker-for-desktop-kubernetes}.
            Die Kubernetes-API des Clusters wurde bei der Implementierung des \ac{lsp}-Servers verwendet, um
            die bestehenden Objekte auf dem Cluster abzufragen und diese für die Autovervollständigung zu verwenden.
      \item[kubectl]
            \textit{kubectl} ist ein Kommandozeilentool, welches zum Erstellen, untersuchen, aktualisieren und löschen von Kubernetes Objekten, sowie zum Ausrollen
            von Anwendungen und verwalten der Cluster-Ressourcen verwendet werden kann. Es kommuniziert dazu mit der Kubernetes-API.\@
            Bei der Entwicklung wurde \textit{kubectl} verwendet, um den momentanen Zustand des Clusters abzufragen,
            um zu verifizieren, welche Objekte der \ac{lsp}-Server zurückgeben muss.
            Außerdem konnte der ``verbose''-Parameter der \textit{kubectl} verwendet, um die benötigten Anfragen an die Kubernetes-API anzeigen zu lassen.
            Diese wurden für die Implementierung des \ac{lsp}-Servers genutzt.
\end{description}

\section{Anforderungen}\label{sec:requirements}

Bevor mit der Implementierung begonnen wurde, wurden Anforderungen zur Autovervollständigung und Validierung festgelegt. Zur Veranschaulichung
dieser Anforderungen stellt Listing~\ref{lst:kubernetes-object-definition} eine nicht vollständige \textit{Manifest}-Datei im \ac{yaml}-Format dar.
Die kommenden Beispiele beziehen sich auf Listing~\ref{lst:kubernetes-object-definition}.

\begin{listing}[htp]
      \begin{minted}[fontsize=\small]{yaml}
      kind: Pod
      spec: 
        priority: high
        volumes: 
          - name: secret-volume
            secret: 
              secretName: 
      metadata: 
        labels: 
        namespace:
        nonexistent:
      \end{minted}
      \caption{Kubernetes Manifest-Datei}
      \label{lst:kubernetes-object-definition}
\end{listing}

\begin{description}
      \item[Anforderung 1]{- Funktionalität für jedes Kubernetes Objekt\\}
            Die Autovervollständigung und Validierung soll dem Nutzer für jedes auf dem Cluster im Standard verfügbare Kubernetes Objekt möglich sein.
            Eine eindeutige Identifikation des Objektes, welches dabei die Felder zur Validierung und Autovervollständigung vorgibt, erfolgt über
            die Angabe des \textit{Mapping}-Schlüssels \textit{apiVersion} und des \textit{Mapping}-Schlüssels \textit{kind}. Sind diese nicht angegeben, kann das definierte Objekt nicht
            eindeutig bestimmt werden.
      \item[Anforderung 2]{- Fehlen eines Mapping-Schlüssels bei Validierung\\}
            Der Nutzer muss darüber informiert werden, welche \textit{Mapping}-Schlüssel in der Datei zur vollständigen Definition fehlen.
            Vorausgesetzt es handelt sich um einen Pflichtschlüssel.
            Der Definition fehlt hier \ac{zB} die \textit{apiVersion}.
      \item[Anforderung 3]{- Definition eines nicht vorhandenen \textit{Mapping}-Schlüssels bei Validierung\\}
            Gibt der Nutzer ein Attribut an, welches nicht in der Definition des Objektes enthalten ist, siehe Zeile 11, so erhält dieser eine Fehlermeldung
      \item[Anforderung 4]{- Typvalidierung eines Scalars\\}
            Ist \ac{zB} der erwartete Wert eines \textit{Scalars} vom Typ ``integer'',
            so muss der Nutzer bei Eingabe einer Zeichenkette darauf hingewiesen werden. Dieser Fehler ist in Zeile 3 zu sehen.
      \item[Anforderung 5]{- Autovervollständigung von Mapping-Schlüsseln\\}
            Dem Nutzer müssen, abhängig vom Kontext, \textit{Mapping}-Schlüssel zur Autovervollständigung angeboten werden.
            Wenn der Nutzer \ac{zB} seinen Cursor in Zeile 12 am Anfang stehen hat, so wird diesem der Schlüssel \textit{apiVersion} angeboten.
      \item[Anforderung 6]{- Autovervollständigung von Mapping-Schlüssel Werten\\}
            Befindet sich der Nutzer mit seinem Cursor im Wertbereich eines \textit{Mapping}-Schlüssels, so sollen diesem, abhängig von diesem, Werte zur Autovervollständigung
            angeboten werden. Die Autovervollständigung von Werten ist nur möglich, falls diese vorhanden sind.
            Befindet sich der Nutzer \ac{zB} mit seinem Cursor im Wertbereich des \textit{Mapping}-Schlüssels \textit{namespace} in Zeile 10,
            werden diesem die verfügbaren \textit{Namespaces} auf dem Kubernetes-Cluster vorschlagen.
            \\
            Folgende Attribute sollen dazu Autovervollständigung mit Hilfe des \textit{Kubernetes API} erhalten:
            \textbf{namespace}, \textbf{secretName}, \textbf{apiVersion}, \textbf{kind} und \textbf{labels}
\end{description}

\section{\acs{lsp}-Client}\label{sec:lsp-client}

Wie bereits zu Beginn des Kapitels erwähnt, wird das Projekt als Erweiterung für den Quellcode-Editor \ac{vscode} entwickelt.
Der Code auf Listing~\ref{lst:client-code} stellt den Einstiegspunkt für die Erweiterung dar.
Dazu wird eine activate- und eine deactivate-Funktion benötigt. Die activate-Funktion enthält Code, der zum Start der Erweiterung ausgeführt wird.
Die deactivate-Funktion enthält Code, welcher beim Beenden der Erweiterung ausgeführt wird.
Die dargestellte activate-Funktion, siehe Zeile 5, enthält außerdem Code zum Start des \ac{lsp}-Clients.
\\
Der \ac{lsp}-Client wird mit Hilfe der Klasse ``LanguageClient'' aus dem Modul ``vscode-languageclient/node'' initialisiert, siehe Zeile 20.
Ein Objekt der Klasse enthält alle notwendigen Funktionalitäten zur Kommunikation mit einem \ac{lsp}-Server.
Zur Initialisierung wird eine Client und eine Server-Konfiguration benötigt.
\\
Die Server-Konfiguration, siehe Zeile 9, gibt an, an welcher Stelle die Implementierung des \ac{lsp}-Servers zu finden ist(Attribut ``module'').
und wie die Kommunikation zwischen \ac{lsp}-Client und Server stattfindet (Attribut ``transport'').
Die Implementierung des \ac{lsp}-Servers kann über die Verzeichnisstruktur des \ac{lsp}-Clients eingebunden werden, siehe Zeile 6, da
ein \textit{Monorepo} zur Entwicklung der Erweiterung genutzt wurde.
Bei einem \textit{Monorepo} handelt es sich um ein \textit{Repository}, das mehrere unterschiedliche Projekte enthält~\cite{monorepo-narwhal}.
Der Vorteil des \textit{Monorepo} besteht im Rahmen des Projektes darin, dass der Client stets mit der aktuellen Version des Servers arbeitet.
Würde sich dieser in einem eigenen \textit{Repository} befinden, so müsste dieser mittels \ac{npm} installiert werden und bei jeder Änderung am Server auf
die neueste Version aktualisiert werden.
Die Kommunikation zwischen \ac{lsp}-Client und Server findet mittels \text{ipc} statt. Dabei handelt es sich um ein Modul von \textit{NodeJS}
zur Interprozesskommunikation. Damit können zwei \textit{NodeJS}-Prozesse, in dem Fall \acs{lsp}-Client und Server, miteinander kommunizieren.
\\
Die Client-Konfiguration, siehe Zeile 13, gibt an für welche Dateien der \ac{lsp}-Server registriert wird. Außerdem wird in Zeile 15 definiert,
für welche Dateien der \ac{lsp}-Server über Änderungen informiert wird.
\\
Der \ac{lsp}-Client wird mit der Anweisung in Zeile 24 gestartet. Der Start des \ac{lsp}-Servers benötigt keine weitere Anweisung.
Dieser wird gestartet, sobald eine \ac{yaml}-Datei geöffnet wird.

\begin{listing}[htp]
      \begin{minted}[fontsize=\footnotesize]{js}
//...
import { LanguageClient, /*...*/ } from 'vscode-languageclient/node';
let client: LanguageClient;
      
export function activate(context: ExtensionContext) {
  const serverModule = context.asAbsolutePath(path.join('server', 'out', 'server.js'));
    //...
  const serverOptions: ServerOptions = {
    run: { module: serverModule, transport: TransportKind.ipc },
    //...
  };
  const clientOptions: LanguageClientOptions = {
    documentSelector: [{ language: 'yaml' }, { pattern: '*.y(a)ml' }],
    synchronize: {
        fileEvents: [workspace.createFileSystemWatcher('**/*.y?(a)ml')]
    }
  };
  client = new LanguageClient(
      //...
      serverOptions,
      clientOptions
  );
  //...
  client.start().catch((reason) => {
      //...
  });
}
//...
      \end{minted}
      \caption{Auszug Implementierung des \acs{lsp}-Clients}
      \label{lst:client-code}
\end{listing}

\section{\acs{lsp}-Server}

Bei der Implementierung des \ac{lsp}-Servers wurden die Anforderungen aus Kapitel~\ref{sec:requirements} umgesetzt.
Der \acs{lsp}-Client stellt lediglich die Anfragen zur Autovervollständigung und Validierung und der Server enthält die Logiken,
um diese Anfragen zu beantworten.
Bevor die Anforderungen umgesetzt wurden, wurde zunächst das Kubernetes Cluster
mit Hilfe von \textit{Docker for Desktop} bereitgestellt. Mit der Bereitstellung des Clusters wird außerdem
ein \textit{kubectl}-Client installiert, der den Zugriff auf das Cluster ermöglicht.

\subsection{Erstellen von \acs{json}-Schema Dateien}

Um die Struktur der \textit{Manifest}-Dateien vorzugeben, bietet sich das in Kapitel~\ref{sec:json-schema} eingeführte \acs{json}-Schema an.
Damit lässt sich vorgeben, welche Attribute vorhanden sind, welche Attribute angegeben werden müssen und welche Typen diese haben.
Es wäre demnach möglich für alle Kubernetes Objekte händisch ein \acs{json}-Schema zu schreiben. Dies würde jedoch viel Zeit in Anspruch nehmen und
könnte bei neuen Kubernetes-Versionen mit Änderungen, die die Struktur und Syntax von \textit{Manifest}-Dateien betreffen, wieder zu einem hohen Aufwand führen.
\\
Stattdessen bietet die \textit{KubernetesAPI} die Möglichkeit den Aufbau der \textit{Manifest}-Dateien mit Hilfe der \textit{OpenAPI}-Spezifikation abzuleiten.
\\
Bei \textit{OpenAPI} handelt es sich um einen Standard zur Beschreibung von Anwendungsschnittstellen, auch~\ac{apis} genannt. Die Beschreibung der \acs{api} ist
unabhängig von einer Programmiersprache und wird im \ac{json}- oder \ac{yaml}-Format zur Verfügung gestellt~\cite{openapi-org}.
Die \textit{KubernetesAPI} stellt die \textit{OpenAPI}-Spezifikation im \ac{json}-Format bereit und diese kann anschließend durch einen Konverter in
mehrere Dateien umgewandelt werden, sodass diese jeweils ein \acs{json}-Schema eines Kubernetes Objektes enthalten.
\\
Zum Erstellen der \acs{json}-Schema-Dateien wurde wie folgt vorgegangen:

\begin{description}
      \item[1. KubernetesAPI mittels Proxy zugänglich machen]
            Bevor der Konverter auf die \textit{OpenAPI}-Spezifikation des Kubernetes Clusters zugreifen kann, muss die \textit{KubernetesAPI}
            für HTTP-Aufrufe ohne Nutzung von \textit{kubectl} verfügbar gemacht werden. Dies wird mit einem \textit{Proxy} erreicht, der über die \textit{kubectl}
            bereitgestellt werden kann. \\
            Ein \textit{Proxy} ist ein Vermittler zwischen zwei Netzwerken~\cite{proxy-ryte-wiki,proxy-it-service-network}.
            Für das Projekt macht der \textit{Proxy} die \textit{KubernetesAPI} über die lokale \acs{ip}-Adresse des Rechners erreichbar.
            Dazu wird folgende Anweisung verwendet:
            \begin{minted}[linenos=false]{console}
                  kubectl proxy
            \end{minted}
      \item[2. Installieren des Konverters]
            Der ausgewählte Konverter ist in Python implementiert. Um den Konverter auszuführen wird daher ein Python-Interpreter benötigt.
            Um den Konverter als Kommandozeilentool zu nutzen, muss außerdem das Paketverwaltungsprogramm \textit{pip} installiert sein.
            Der Konverter kann dann über folgende Anweisung installiert werden~\cite{openapi-to-json-schema}:
            \begin{minted}[linenos=false]{console}
                  pip install openapi2jsonschema
            \end{minted}
      \item[3. Umwandlung der \textit{OpenAPI}-Spezifikation in JSON-Schema Dateien]
            Die \textit{OpenAPI}\\-Spezifikation kann nach Ausführung der vorherigen Schritte mit folgender Anweisung umgewandelt werden:
            \begin{minted}[linenos=false, breaklines]{console}
                  openapi2jsonschema -o path/to/output/directory --kubernetes --strict http://localhost:8001/openapi/v2
            \end{minted}
            Der Parameter ``-o'' gibt an, in welchem Verzeichnis die \ac{json}-Schema-Dateien abgelegt werden sollen.
            Mit dem Parameter ``--kubernetes'' werden zusätzliche Informationen über das betreffende Kubernetes Objekt als Attribut im \ac{json}-Schema gespeichert.
            ``--strict'' ist ein Parameter, welcher angibt, dass keine nicht vorhanden \textit{Mapping}-Schlüssel erlaubt sind bei der Definition einer Datei erlaubt sind.
            Dies wird mit einer \textit{Property} in den generierten \ac{json}-Schema-Dateien erreicht.
            Die angegebene \ac{url} führt zur \textit{OpenAPI}\\-Spezifikation.
\end{description}

Die generierten \ac{json}-Schema Dateien ermöglichen das Erfüllen von \textbf{Anforderung 1} aus Kapitel~\ref{sec:requirements}.

\subsection{Konzeption}

Im nächsten Schritt wurde ein Modul für \textit{NodeJS} gesucht, mit dem eine \ac{yaml}-Datei mit Hilfe eines \ac{json}-Schemas validieren
und autovervollständigen kann. Es wurde das Modul ``vscode-json-languageservice'' ausgewählt, dass von Microsoft im Editor \ac{vscode} verwendet
wird. Das gewählte Modul kann allerdings nur eine \ac{json}-Datei anhand eines \ac{json}-Schemas validieren
und autovervollständigen. Um die Funktionalitäten für \ac{yaml}-Dateien zu ermöglichen, waren grundlegende Änderungen an dem Modul nötig.
Der Code des Moduls wurde als Grundlage für die Implementierung der Sprachunterstützung genutzt.
Das Modul stellt ein \textit{Interface} bereit, welches einen Überblick über die Funktionalitäten gibt und aufzeigt, welche Änderungen
nötig sind, um diese für \ac{yaml}-Dateien zu nutzen.
\\
Abbildung~\ref{fig:language-service-interface-defition-excerpt} zeigt einen Auszug, der für die Implementierung
der Funktionalität bei \ac{yaml}-Dateien relevanten, Methoden des \textit{Interface} ``LanguageService''.
Die vollständige Definition \textit{Interface} befindet sich im Anhang auf Abbildung \ref{fig:language-service-interface-defition}.
Es folgt eine Beschreibung der einzelnen Methoden~\cite{vscode-json-language-service}:

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
      \centering
      \includesvg[width=0.75\textwidth]{images/language-service-interface-excerpt.svg} % width immer angeben!
      \caption{Auszug des Klassendiagramms des \textit{Interface} ``LanguageService''}
      \label{fig:language-service-interface-defition-excerpt}
\end{figure}


\begin{description}
      \item[parseJSONDocument]
            Parst eine \ac{json}-Datei speichert den Inhalt in einem Objekt der Klasse \textit{JSONDocument}.
            Der Parameter der Klasse \textit{TextDocument} enthält den Inhalt einer Datei, welcher durch den \ac{lsp}-Client an den \ac{lsp}-Server gesendet wird.
      \item[doComplete]
            Ermöglicht die Autovervollständigung einer \ac{json}-Datei mit einem \ac{json}-Schema. Das betreffende \ac{json}-Schema wird bei der
            Initialisierung des ``LanguageService'' übergeben.
            Als Parameter werden ein Objekt der Klasse \textit{TextDocument}, ein Objekt der Klasse \textit{JSONDocument} und ein Objekt
            des Typs \textit{Position} benötigt, welches die Zeile und Spalte angibt, in dem sich der Cursor des Nutzers befindet.
            Die Methode liefert als Ergebnis eine Liste von Elementen zur Autovervollständigung, falls vorhanden.
      \item[doValidation] Ermöglicht die Validierung einer \ac{json}-Datei mit einem \ac{json}-Schema.
            Als Parameter werden ein Objekt der Klasse \textit{TextDocument}, ein Objekt der Klasse \textit{JSONDocument} benötigt.
            Die Methode liefert als Ergebnis einen Array mit Fehlern, die bei der Validierung gefunden wurden.
            Dabei werden Fehler bei der Validierung mittels \ac{json}-Schema und Syntaxfehler zurückgegeben.
\end{description}

Die Methoden zur Validierung und Autovervollständigung benötigten jeweils ein Objekt der Klasse \textit{JSONDocument}, welches durch das Parsen einer
\ac{json}-Datei erzeugt wird.
Der Aufbau der Klasse \textit{JSONDocument} wurde als Nächstes analysiert, um festzustellen, welche Anforderungen der Parser einer \ac{yaml}-Datei
erfüllen muss, damit mit den Ergebnissen des Parsers ein Objekt erzeugt werden kann.

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
      \centering
      \includesvg[width=0.3\textwidth]{images/class-diagram-json-document-excerpt.svg} % width immer angeben!
      \caption{Auszug des Klassendiagramms der Klasse ``JSONDocument''}
      \label{fig:class-diagram-json-document-excerpt}
\end{figure}

Aus dem Auszug des Klassendiagramms auf Abbildung~\ref{fig:class-diagram-json-document-excerpt} können die Anforderungen an
den Parser aus den Attributen der Klasse abgeleitet werden:
\begin{description}
      \setlength\itemsep{-0.5cm}
      \item[root]
            In dem Attribut wird eine Baumstruktur des Aufbaus einer \ac{json}-Datei gespeichert. Der Parser muss demnach auch einen \ac{ast} erzeugen können,
            der sich in die von der Klasse ``ASTNode'' vorgegebene Struktur konvertieren lässt.
      \item[syntaxErrors] Der Parser muss Syntaxfehler erkennen und speichern.
      \item[comments] Kommentare müssen durch den Parser erkannt und gespeichert werden.
\end{description}

Aufgrund der Anforderungen wurde das Modul ``yaml'' für \textit{NodeJS} ausgewählt. Das Modul erzeugt einen \ac{ast} und parst Syntaxfehler und Kommentare.
Die interne Darstellung des \ac{ast} weicht jedoch von dem \ac{ast}, welcher in der Klasse \textit{JSONDocument} als Attribut \textit{root}
gespeichert wird, ab und muss daher konvertiert werden.
\\
Aus dem erlangten Wissen aus diesem Abschnitt und den Anforderungen aus Abschnitt~\ref{sec:requirements} wurde ein Klassendiagramm erstellt.
Das vollständige Klassendiagramm befindet sich im Anhang auf Abbildung~\ref{fig:class-diagram-lsp-Server}.
In den kommenden Abschnitten wird das gesamte Klassendiagramm mit Auszügen erläutert.

\subsection{Kommunikation mit dem \acs{lsp}-Client}\label{sec:lsp-client-communication}

In Abschnitt~\ref{sec:lsp-client} wurde bereits gezeigt, dass der Client angibt, wie der \ac{lsp}-Server zu erreichen ist.
Die Implementierung des Einstiegspunkts des \ac{lsp}-Servers wird auf Listing~\ref{lst:server-entrypoint} dargestellt.
Dabei wurden die Module ``vscode-languageserver/node'' und ``vscode-languageserver-textdocument'' genutzt, um die
Implementierung der \ac{lsp}-Funktionalitäten zur vereinfachen.
\\
Zunächst wird ein Objekt der Klasse ``\_Connection'' erstellt mit der Funktion ``createConnection'' erstellt, siehe Zeile 10.
Die Klasse liefert Funktionalitäten zur Kommunikation mit dem \ac{lsp}-Client.
Eine Funktionalität ist \ac{zB} die Möglichkeit auf eine Anfrage zur Autovervollständigung des \ac{lsp}-Clients zu reagieren.
\\
In Zeile 11 wird der ein Objekt erstellt, dass für Verwaltung von Textdateien auf dem Server zuständig ist.
Die Textdateien sind ein Abbild der vorhandenen Textdateien, die dem Client zur Verfügung stehen.
Dieses Objekt wird im folgenden als \textit{DocumentManager} bezeichnet.
Der \textit{DocumentManager} sorgt dafür, dass bei Änderungen einer Textdatei auf der Clientseite diese auch auf dem \ac{lsp}-Server aktualisiert wird.
Zusätzlich kann über Ereignisse des \textit{DocumentManager} auf das Öffnen, Ändern und Schließen einer Textdatei reagiert werden.
\\
Das Verzeichnis, in dem sich der Server befindet, wird in der Variablen ``baseUri'', siehe Zeile 12, als absoluter Pfad gespeichert.
Der absolute Pfad wird zum Zugriff auf die \ac{json}-Schema-Dateien benötigt.
Zuletzt wird in Zeile 13 ein Objekt der Klasse ``YamlLanguageServer'' erzeugt.

\begin{listing}[htp]
      \begin{minted}[fontsize=\footnotesize]{js}
import { 
  createConnection, 
  TextDocuments, 
  //...
} from 'vscode-languageserver/node';
import { TextDocument } from 'vscode-languageserver-textdocument';
import { YamlLanguageServer } from './yamlLanguageServer';
import path from 'path';
//...
const connection = createConnection(/*...*/);
const documentManager: TextDocuments<TextDocument> = new TextDocuments(TextDocument);
const baseUri = path.resolve(__dirname, '../');
new YamlLanguageServer(connection, documentManager, baseUri);
      \end{minted}
      \caption{Auszug Implementierung des Einstiegspunkts des \acs{lsp}-Servers}
      \label{lst:server-entrypoint}
\end{listing}


Die Klasse ``YamlLanguageServer'' ist eine Kommunikationsschnittstelle zum \ac{lsp}-Client.
Einen Überblick über die Implementierung der Klasse liefert Listing~\ref{lst:server-entrypoint}.
In Zeile 6 wird ein Objekt der Klasse ``ConfigurationService'' erzeugt. Das Objekt kümmert sich
mit Hilfe von Methoden der ``\_Connection''-Klasse um die Initialisierung der Verbindung mit dem \ac{lsp}-Client.
\\
Die ``onCompletion''-Methode enthält die Logik zur Autovervollständigung. Diese wird bei einer Client-Anfrage
aufgerufen, siehe Zeile 8.
\\
Bei Änderungen an einer Textdatei wird der \textit{DocumentManager} benachrichtigt und die geänderte Datei
wird durch die ``validateTextDocument''-Methode validiert, siehe Zeile 10 und 11.
\\
Die Autovervollständigung und Validierung, die in den Methoden erfolgt, wird durch eine weitere Klasse, ``YamlLanguageService'', koordiniert.

\begin{listing}[htp]
      \begin{minted}[fontsize=\footnotesize]{js}
public constructor(
  private connection: _Connection,
  private documentManager: TextDocuments<TextDocument>,
  private baseUri: string
) {
    new ConfigurationService(connection);
    //...
    this.connection.onCompletion(this.onCompletion.bind(this));
    //...
    this.documentManager.onDidChangeContent((change) => {
        this.validateTextDocument(change.document);
    });
    //...
  }
      \end{minted}
      \caption{Auszug Implementierung des Konstruktors der Klasse ``YamlLanguageServer''}
      \label{lst:server-entrypoint}
\end{listing}

\subsection{Parsen von \acs{yaml}-Dateien}

Bevor eine Autovervollständigung oder eine Validierung einer Datei stattfinden kann, muss die \ac{yaml}-Datei geparst und
der \ac{ast} in die von der Klasse ``ASTNode'' vorgegebene Struktur umgewandelt werden.
Abbildung~\ref{fig:class-diagram-yaml-language-service-parser} stellt die beteiligten Klassen, mit wichtigen Methoden und Attributen,
beim Parsen einer \ac{yaml}-Datei dar.

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
      \centering
      \includesvg[width=1.0\textwidth]{images/class-diagram-yaml-language-service-parser.svg} % width immer angeben!
      \caption{Auszug des Klassendiagramms der benötigten Klassen zum Parsen}
      \label{fig:class-diagram-yaml-language-service-parser}
\end{figure}

Das Parsen einer \ac{yaml}-Datei beginnt mit dem Aufruf der ``parseYamlDocument''-Methode der Klasse ``YamlLanguageService''.
Dieser Methode wird die Textdatei, welche geparst werden soll übergeben. Innerhalb der Methode erfolgt ein Aufruf
der Methode ``parse'' der Klasse ``YamlParser''.
\\
Listing~\ref{lst:parse-yaml-parser} zeigt einen Auszug des Quellcodes der ``parse''-Methode der Klasse ``YamlParser''.
\\
Die Methode nimmt eine Textdatei entgegen und liefert einen Array von Objekten der Klasse ``YamlDocument'' zurück.
Mit dem Objekt der Klasse ``Parser'' werden mit einer lexikalischen Analyse \textit{Token} erzeugt, siehe Zeile 5 bis 7.
Anschließend wird jeweils eine Menge von \textit{Token} zu einem \ac{yaml}-Document zusammengefasst.
Dies geschieht in Zeile 10 und 11 mit einem Objekt der Klasse ``Composer''.
Dabei wird eine syntaktische Analyse durchgeführt. Die Variable ``documents'' enthält damit einen Array
von Objekten die Syntaxfehler und einen \ac{ast} bereitstellen.
Die Syntaxfehler werden in Zeile 15 ausgelesen und gespeichert.
Der \ac{ast} wird in Zeile 23 mittels ``convert''-Methode der Klasse ``AstConverter'' umgewandelt.
Dieser befindet sich somit im richtigen Format für die weitere Verarbeitung.
Zuletzt werden in Zeile 31 die Kommentare aus der Menge von \textit{Token} ausgelesen und dem jeweiligen ``YamlDocument''-Objekt zugeordnet.

\begin{listing}[t]
      \begin{minted}[fontsize=\footnotesize]{js}
public parse(textDocument: TextDocument): YamlDocument[] {
    this.yamlDocuments = [];
    const text = textDocument.getText();  
    //...
    const parser = /*...*/ new Parser() /*...*/;
    const parsedTokens = parser.parse(text);
    const tokens: CST.Token[] = Array.from(parsedTokens);
    let syntaxErrorDiagnostics: Diagnostic[];
    //...  
    const composer = new Composer(/*...*/);
    const documents = composer.compose(tokens, true, text.length);
    for (const document of documents) {
      //...
      syntaxErrorDiagnostics = [];
      for (const error of document.errors) {
        syntaxErrorDiagnostics.push(
            //...
        );
      }
      //...
      if (document.contents) {
        const astConverter = new AstConverter();
        const astNode = astConverter.convert(document.contents, /*...*/);
        const yamlDocument = 
          new YamlDocument(astNode, textDocument, syntaxErrorDiagnostics);
        //...   
        this.yamlDocuments.push(yamlDocument);
      }
    }
    //...          
    this.parseCommentsFromTokens(textDocument, tokens);
    return this.yamlDocuments;
  }
      \end{minted}
      \caption{Auszug Quellcode ``parse''-Methode der Klasse ``YamlParser''}
      \label{lst:parse-yaml-parser}
\end{listing}

Für die Implementierung der ``convert''-Methode der Klasse ``AstConverter'' wurde der Aufbau des \ac{ast} des genutzten Parsers für
die Dateien im \ac{yaml}-Format und der Aufbau des \ac{ast} des Parsers für die \ac{json}-Dateien verglichen.
Es wurde eine Zuordnungstabelle angelegt, um die Konvertierung zu implementieren.
Diese Zuordnungstabelle ist auf Tabelle~\ref{tbl:yaml-ast-to-json-ast-convert} zu sehen.
Sie zeigt eine Zuordnung der Objekttypen der beiden Formate zu deren Klassen der \ac{ast}-Implementierung.
Mit den Informationen aus der Tabelle wurde ein Algorithmus erstellt, der den \ac{ast} der \ac{yaml}-Datei rekursiv traversiert und konvertiert.
%Der Quellcode der Implementierung der  ``convert''-Methode befindet sich im Anhang.

\begin{table}[h]
      \centering
      \begin{tabular}{|l|l|l|l|}
            \hline
            \acs{yaml}-Objekttyp    & Klasse \acs{yaml}-\acs{ast} & \acs{json}-Objekttyp   & Klasse \acs{json}-\acs{ast} \\
            \hline
            \hline
            Sequence                & YamlSeq                     & Array                  & ArrayAstImpl                \\
            \hline
            Mapping                 & YamlMap                     & Object                 & ObjectAstImpl               \\
            \hline
            Pair                    & Pair                        & Property               & PropertyAstImpl             \\
            \hline
            \multirow{4}{*}{Scalar} & \multirow{4}{*}{Scalar}     & \multirow{4}{*}{Value} & StringAstImpl               \\
                                    &                             &                        & NumberAstImpl               \\
                                    &                             &                        & BooleanAstImpl              \\
                                    &                             &                        & NullAstImpl                 \\
            \hline
            Mapping-Schlüssel       & Scalar                      & Key                    & StringAstImpl               \\
            \hline
      \end{tabular}
      \caption{Zuordnungstabelle der Klassen der verschiedenen \acs{ast}-Implementierungen}
      \label{tbl:yaml-ast-to-json-ast-convert}
\end{table}

\subsection{Validierung}

Als Nächstes erfolgte die Implementierung der Validierung. Wie bereits in Abschnitt~\ref{sec:lsp-client-communication} erwähnt wird die
Validierung bei jeder Änderung an einer \ac{yaml}-Datei, die durch den Nutzer erfolgt, durchgeführt.
Auf Abbildung~\ref{fig:class-diagram-yaml-language-service-validation} ist dazu ein Auszug des Klassendiagramms der beteiligten Klassen dargestellt.
Da die Umwandlung des \ac{ast} erfolgt ist, konnten die bereits bestehenden Klassen ``JSONValidation'' und ``JSONSchemaService''
des Moduls ``vscode-json-languageservice'' verwendet und bei Bedarf erweitert werden.

\begin{figure}[t] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
      \centering
      \includesvg[width=0.7\textwidth]{images/class-diagram-yaml-language-service-validation.svg} % width immer angeben!
      \caption{Auszug des Klassendiagramms der benötigten Klassen zur Validierung}
      \label{fig:class-diagram-yaml-language-service-validation}
\end{figure}

Die Validierung beginnt mit dem Aufruf der Methode ``doValidation'' der Klasse ``YamlLanguageService'', welcher
durch eine Änderung an einer \ac{yaml}-Datei auf Clientseite ausgelöst wird.
Vor jeder Validierung findet das Parsen der \ac{yaml}-Datei mit der im vorherigen Abschnitt erwähnten Methode ``parseYamlDocument'' statt.
Die Methode ``doValidation'' der Klasse ``JSONValidation'' wird anschließend aufgerufen. An dieser mussten keine Änderungen durchgeführt werden.
In der Methode wird mit Hilfe von einem Objekt der Klasse ``JSONSchema'' und dessen Methode ``getSchemaForResource'' ein geeignetes \ac{json}-Schema
für die zu validierende \ac{yaml}-Datei gesucht. Diese Suche wurde erweitert, sodass sie das \ac{json}-Schema anhand
der \textit{Mapping}-Schlüssel ``apiVersion'' und ``kind'' auswählt.
Ist keiner oder nur einer der \textit{Mapping}-Schlüssel vorhanden, gibt es kein eindeutiges Ergebnis, was dem Nutzer durch eine Warnung angezeigt wird.
Wird ein \ac{json}-Schema gefunden, findet anhand dessen eine Validierung statt und dem Nutzer werden mögliche Fehler angezeigt.
Da für die Validierung mittels \ac{json}-Schema die bereits vorhandenen Klassen genutzt oder erweitert wurden,
konnten damit die \textbf{Anforderungen 2}, \textbf{3} und \textbf{4} aus Abschnitt~\ref{sec:requirements} erfüllt werden.

\subsection{Autovervollständigung}

Der Auslöser für die Autovervollständigung ist das Betätigen einer Tastenkombination auf der Clientseite. Der \ac{lsp}-Client signalisiert dem \ac{lsp}-Server,
dass eine Autovervollständigung vom Nutzer gewünscht ist und übergibt die Position des Cursors in der Datei.
Anschließend wird vom \ac{lsp}-Server die ``doComplete''-Methode des Objekts der Klasse ``YamlLanguageServer'' aufgerufen.
In der Methode wird die \ac{yaml}-Datei geparst und das \ac{yaml}-\textit{Document} gefunden, in welchem sich der Cursor befindet.
Dieses wird dem Inhalt der Textdatei und der Position des Cursors an die Methode ``doComplete'' der Instanz der Klasse ``YamlLanguageService'' übergeben.
Ein Ausschnitt des Quellcodes der Methode ist auf Listing zu sehen.

\begin{listing}[htp]
      \begin{minted}[fontsize=\footnotesize]{js}
async doComplete(document: TextDocument, position: Position, doc: YamlDocument)
: Promise<CompletionList | null> 
{
  const compColl: CompletionsCollectorImpl = new CompletionsCollectorImpl();
  //...
  const offset = document.offsetAt(position);
  const node = doc.getNodeFromOffset(offset);
  const documentInfo: DocumentInfo = {
    document: document,
    yamlDocument: doc,
    position: position
  };

  await this.schemaCompletionService.doComplete(node, compColl, documentInfo);
  await this.schemaLessCompletionService.doComplete(node, compColl, documentInfo);

  return compColl.getCompletionList();
}
      \end{minted}
      \caption{Auszug Quellcode ``doComplete''-Methode der Klasse ``YamlLanguageService''}
      \label{lst:do-complete-yaml-language-service}
\end{listing}

Das Objekt der Klasse ``CompletionsCollectorImpl'' dient zum Speichern der möglichen Autovervollständigungen, siehe Zeile 3.
\\
Bevor diese gefunden werden können, muss der Kontext der Position des Cursors bestimmt werden.
Dieser wird mit der Methode ``getNodeFromPosition'' der Klasse ``YamlDocument'' bestimmt, siehe Zeile 7.
Dafür wird der Knoten im \ac{ast} gesucht, welcher den Wert enthalten würde, den der Nutzer vervollständigen möchte.
Der gefundene Knoten könnte \ac{zB} ein \textit{Mapping}-Schlüssel sein.
Zur Autovervollständigung würde der Nutzer mögliche Werte für den \textit{Mapping}-Schlüssel vorgeschlagen bekommen.
Ein Ablaufdiagramm der ``getNodeFromPosition''-Methode befindet sich im Anhang.
\\
Anschließend können durch die Objekte der Klassen ``SchemaCompletionService'' und ``SchemalessCompletionService''
die Vorschläge zur Autovervollständigung unter Berücksichtigung des Kontexts gesammelt werden.
Dies wird jeweils mit dem Aufruf der ``doComplete''-Methode erreicht, siehe Zeile 14 und Zeile 15.
Die Methode liefert abschließend in Zeile 17 die Vorschläge zur Autovervollständigung.
\\
\\
Das Objekt der Klasse ``SchemaCompletionService'' liefert Autovervollständigungen mit Hilfe der \ac{json}-Schema-Dateien.
Dazu wird, wie bei der Validierung, das Objekt der Klasse ``JSONSchemaService'' um das \ac{json}-Schema für das \ac{yaml}-\textit{Document}
zu ermitteln. Die Klasse ``SchemaCompletionService'' wurde auf Grundlage der Klasse ``JSONCompletionService'' des Moduls ``vscode-json-languagservice''
entwickelt. Es wurden Anpassungen vorgenommen, die bei der Autovervollständigung aufgrund des \ac{yaml}-Formates notwendig waren.
Hier musste z.B. verhindert werden, dass bei der Vervollständigung eines \ac{json}-\textit{Keys} dieser mit Anführungszeichen eingeschlossen wurde.
Im \ac{yaml}-Format ist dies für einen \textit{Mapping}-Schlüssel nicht erlaubt.
Die Klasse ``SchemaCompletionService'' erfüllt \textbf{Anforderung 5} aus Abschnitt~\ref{sec:requirements}.
\\
\\
Das Objekt der Klasse ``SchemalessCompletionService'' liefert Autovervollständigungen mit Hilfe der \textit{KubernetesAPI} und
sammelt außerdem Informationen von Kubernetes Objekten, aus dem aktuellen und anderen auf dem Client geöffneten Dokumenten, die noch nicht auf das
Cluster ausgerollt wurden.
Abbildung~\ref{fig:class-diagram-yaml-language-service-schemaless-completion} zeigt einen Auszug des Klassendiagramms der dazu benötigten Klassen.

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
      \centering
      \includesvg[width=1.0\textwidth]{images/class-diagram-yaml-language-service-schemaless-completion.svg} % width immer angeben!
      \caption{Auszug des Klassendiagramms der benötigten Klassen zur Autovervollständigung mit KubernetesAPI}
      \label{fig:class-diagram-yaml-language-service-schemaless-completion}
\end{figure}

Die Klasse ``KubernetesApiService'' ist die Schnittstelle zur \textit{KubernetesAPI}. Sie sendet Anfragen über das \ac{https}-Protokoll zum \textit{API-Server}
des Kubernetes Clusters und verarbeitet die Antworten. Wie in \textbf{Anforderung 6} aus Abschnitt~\ref{sec:requirements} festgelegt,
speichert ein Objekt der Klasse ``KubernetesApiService'' die Informationen über folgende Kubernetes Objekte auf dem Cluster: \textit{Namespace} und \textit{Secret}.
Es wird zusätzlich eine Liste aller verfügbaren Objekttypen(``kind'') mit deren Version(``apiVersion'') gespeichert.
Zuletzt werden die verfügbaren \textit{Labels} des Clusters festgehalten.
Die Informationen werden in einem \textit{Cache} abgelegt und nach Ablauf einer Zeitspanne erneut vom Cluster abgefragt, siehe
Attribut ``cacheMap'' der Klasse ``KubernetesApiService''.
Die Ablaufzeit und die Zugangsdaten des Clusters können vom Nutzer über eine Einstellung in der \ac{vscode}-Erweiterung
konfiguriert werden. Diese Einstellungen sind im Attribut ``settings'' bereitgestellt.
\\
Die ``buildCompletionCache''-Methode der Klasse ``SchemalessCompletionService'' sammelt anhand der \textit{Mapping}-Schlüssel
der Ressourcen, die die Klasse ``KubernetesApiService'' speichert, die Werte aus der aktuellen und anderen geöffneten Dateien.
Damit kann \ac{zB} ein \textit{Namespace} dem Nutzer als Autovervollständigung angeboten werden, der noch nicht auf dem Cluster vorhanden ist,
die \textit{Manifest}-Datei zur Erstellung aber bereits angelegt wurde.
\\
Das Problem bei der Autovervollständigung von Werten aus dem Cluster ist, dass anhand des \ac{json}-Schemas nicht bestimmt werden kann,
welches Kubernetes Objekt welchem \textit{Mapping}-Schlüssel in der \textit{Manifest}-Datei zugeordnet ist.
Das \ac{json}-Schema bietet nicht die Möglichkeit zur Definition eigener Typen.
\\
Der \textit{Mapping}-Schlüssel für einen \textit{Namespace} ist \ac{zB} vom Typ ``string'' und kann ohne weitere Informationen nicht in der Datei vervollständigt werden.
Die Lösung dafür ist eine eigene Zuordnung von \textit{Mapping}-Schlüsseln zu Kubernetes Objekten oder anderen aus dem Cluster gespeicherten Informationen anzulegen.
Die Implementierung dieser Lösung ist unabhängig von den \ac{json}-Schema-Dateien möglich.
\\
Bei der Implementierung wurde ein Entwurfsmuster aus der Softwareentwicklung verwendet, welches als ``Template Method'' bezeichnet wird.
``Template Method'' ist ein sogenanntes Verhaltensmuster, welches den Aufbau eines Algorithmus in einer Basisklasse beschreibt und
die abgeleiteten Klassen spezifische Schritte des Algorithmus überschreiben lässt.
Die Basisklasse definiert dazu eine abstrakte Methode, welche als Platzhalter agiert und optional eine Standardimplementierung besitzt.
Die abgeleiteten Klassen überschreiben diese Methode und andere Methoden, die an dem Prozess beteiligt sind, um
das Verhalten für einen spezifischen Anwendungsfall zu ändern oder zu vervollständigen~\cite{typescript-design-pattern-chapter-6,design-patterns-refactoring-guru}.
Abbildung~\ref{fig:class-diagram-completion-rule} zeigt das Klassendiagramm der Anwendung des Verhaltensmusters zum Bestimmen von Werten zur Autovervollständigung.

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
      \centering
      \includesvg[width=0.8\textwidth]{images/class-diagram-completion-rule.svg} % width immer angeben!
      \caption{Auszug des Klassendiagramms zur Anwendung des ``Template Method''-Verhaltensmuster}
      \label{fig:class-diagram-completion-rule}
\end{figure}

Die Basisklasse ist die Klasse ``CompletionRule''. Sie liefert Werte zur Autovervollständigung mittels der Methode ``getCompletionValues''.
Sie wird von mehreren Klassen erweitert, die die benötigten Informationen vom Kubernetes Cluster bereitstellen. Diese Klassen
werden im Folgen als Regeln zur Vervollständigung bezeichnet.
Beispielhaft ist die Klasse ``SecretCompletionRule'' zu sehen, welche die verfügbaren \textit{Secrets} auf dem Kubernetes Cluster abfragt.
Es folgt eine Beschreibung der übrigen dargestellten Methoden und Attributen der Klassen:
\begin{description}
      \setlength\itemsep{-0.5cm}
      \item[keys]
            Gibt an für welche \textit{Mapping}-Schlüssel die Werte zur Autovervollständigung dem Nutzer angeboten werden.
            Das Attribut muss von abgeleiteten Klassen überschrieben werden.
            Für Klasse ``SecretCompletionRule'' enthält das Attribut den Wert den \textit{Mapping}-Schlüssel ``secretName''.
      \item[shouldCollectValuesFromDocuments]
            Gibt an, ob für die angegebene Menge von ``keys'' Werte aus dem aktuellen und anderen geöffneten Dateien gesammelt werden sollen.
            Das Attribut muss von abgeleiteten Klassen überschrieben werden.
      \item[getApiCompletionValues]
            Die abstrakte Methode muss von den abgeleiteten Klassen überschrieben werden. Sie für die Abfrage der benötigten Werte vom Cluster zuständig.
      \item[test]
            Die abstrakte Methode muss von den abgeleiteten Klassen überschrieben werden. Mit ihr können zusätzliche Einschränkungen
            für die Autovervollständigung definiert werden. Damit kann \ac{zB} festgelegt werden, welchen Elternknoten im \ac{ast}
            ein \textit{Mapping}-Schlüssel haben muss, damit der Nutzer Werte zur Autovervollständigung erhält.
      \item[isApplicable]
            Ermittelt mit Hilfe der ``test''-Methode, ob Werte zur Autovervollständigung für einen gegebenen Knoten im \ac{ast}
            gesucht werden sollen.
\end{description}

Der Ausschnitt des Quellcodes der ``getCompletions''-Methode der Klasse ``SchemalessCompletionService'' veranschaulicht, wie Objekte der
Kindklassen der Klasse ``CompletionRule'' verwendet werden, um die Werte zur Autovervollständigung für den Nutzer bereitzustellen.
Diese Klassen
Der Ausschnitt des Quellcodes ist auf Listing zu sehen. Die Methode aus der Methode ``doComplete'' aufgerufen.
Sie erhält als Übergabeparameter den Knoten und den \textit{Mapping}-Schlüssel die den Wert enthalten, sowie den Parameter vom Typ
``DocumentInfo''. Dieser enthält die Position des Cursors, die Textdatei und das \ac{yaml}-\textit{Document}, in dem sich die
Position des Cursors befindet. Das ``completionRules''-Attribut in Zeile 5 enthält je eine Instanz der Regeln zur Vervollständigung.

\begin{listing}[t]
      \begin{minted}[fontsize=\footnotesize]{js}
private async getCompletions(
        node: ASTNode,
        key: string,
        documentInfo: DocumentInfo,
        //...
    ): Promise<CompletionItem[]> {
let completions: CompletionItem[] = [];
  for (const completionRule of this.completionRules) {
    if (completionRule.isApplicable(node, key, /*...*/)) {
      const apiCompletionValues = await completionRule.getCompletionValues(documentInfo);
      completions = [
        ...completions,
        ...apiCompletionValues,
        ...this.getCachedCompletionsFromDocuments(completionRule)
      ];
    }
  }
  return completions;
}
      \end{minted}
      \caption{Auszug Quellcode ``getCompletions''-Methode der Klasse ``SchemalessCompletionService''}
      \label{lst:get-completions-schemaless-completion-service}
\end{listing}

\section{Bereitstellen der \acs{vscode}-Erweiterung}

Nach Abschluss der Implementierung wurde die \acs{vscode}-Erweiterung aus dem Quellcode erstellt.
Dazu wurde das Kommandozeilentool \textit{vsce} 