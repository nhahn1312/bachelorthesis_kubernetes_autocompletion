\chapter{Implementierung}\label{ch:implementation}

Um die in Kapitel~\ref{ch:introduction} gestellten Forschungsfragen zu beantworten, wurde ein \ac{lsp}-Server und ein \ac{lsp}-Client entwickelt,
welche die Autovervollständigung und Validierung von Kubernetes \textit{Manifest}-Dateien ermöglichen.
Die beiden Komponenten wurden als installierbare Erweiterung für den Quellcode-Editor \ac{vscode} bereitgestellt.

\section{Technologien}

\begin{description}
      \item[NodeJS]
            Bei \textit{NodeJS} handelt es sich um eine plattformübergreifende Laufzeitumgebung, mit welcher Javascript-Programme entwickelt werden können,
            die unabhängig von Host-Anwendungen, wie \ac{zB} dem Webbrowser laufen.
            Das Konzept des ``non-blocking I/O'' wird von \textit{NodeJS} für die parallele und asynchrone Ausführung von Code verwendet.
            Programme müssen dabei nicht auf die Ergebnisse einer Ein-/Ausgabe-Funktion warten,
            sondern werden über ein Ereignis über die Beendigung informiert.
            \textit{NodeJS} lässt sich mit Modulen erweitern.
            Der sogenannte \ac{npm} unterstützt den Entwickler dabei und kann Module sowie deren Abhängigkeiten suchen,
            installieren, entfernen und aktualisieren.~\cite{node-js-dev-insider,node-js-about}.
            Im Rahmen des Projektes wurden mit Hilfe von NodeJS der \ac{lsp}-Client und \ac{lsp}-Server implementiert.
      \item[Typescript]
            \textit{Typescript} ist eine Skriptsprache, die eine syntaktische Obermenge von Javascript ist. Das heißt, dass \textit{Typescript} und Javascript
            die gleiche Syntax besitzen, Typescript jedoch noch über zusätzliche Syntax verfügt.
            \textit{Typescript} erlaubt dem Programmierer \ac{zB} die statische Typisierung von Variablen, Funktionsparametern und Rückgabetypen.
            Die Code-Qualität kann dadurch erhöht werden. Ein Compiler übersetzt \textit{Typescript}-Code in lauffähigen Javascript-Code, welcher dann von einer
            wie \ac{zB} \textit{NodeJS} ausgeführt werden kann~\cite{typescript-kinsta,typescript-doubleslash-blog}.
            Der \ac{lsp}-Client und \ac{lsp}-Server wurden mit der Skriptsprache \textit{Typescript} entwickelt.
      \item[Docker for Desktop]
            Mit \textit{Docker for Desktop} lassen sich Anwendungen in \textit{Containern} zusammenstellen, teilen und ausführen.
            Das Programm ist für Mac, Linux und Windows Umgebungen verfügbar und bietet ein \ac{gui} zur Verwaltung der \textit{Container} an~\cite{docker-for-desktop-overview}.
            \textit{Docker for Desktop} enthält außerdem ein Kubernetes-Cluster, welches lokal auf einem einzigen \textit{Node} ausgeführt wird~\cite{docker-for-desktop-kubernetes}.
            Die Kubernetes-API des Clusters wurde bei der Implementierung des \ac{lsp}-Servers verwendet, um
            die bestehenden Objekte auf dem Cluster abzufragen und diese für die Autovervollständigung zu verwenden.
      \item[kubectl]
            \textit{kubectl} ist ein Kommandozeilentool, welches zum Erstellen, untersuchen, aktualisieren und löschen von Kubernetes Objekten, sowie zum Ausrollen
            von Anwendungen und verwalten der Cluster-Ressourcen verwendet werden kann. Es kommuniziert dazu mit der Kubernetes-API.\@
            Bei der Entwicklung wurde \textit{kubectl} verwendet, um den momentanen Zustand des Clusters abzufragen,
            um zu verifizieren, welche Objekte der \ac{lsp}-Server zurückgeben muss.
            Außerdem konnte der ``verbose''-Parameter der \textit{kubectl} verwendet, um die benötigten Anfragen an die Kubernetes-API anzeigen zu lassen.
            Diese wurden für die Implementierung des \ac{lsp}-Servers genutzt.
\end{description}

\section{Anforderungen}\label{sec:requirements}

Bevor mit der Implementierung begonnen wurde, wurden Anforderungen zur Autovervollständigung und Validierung festgelegt. Zur Veranschaulichung
dieser Anforderungen stellt Listing~\ref{lst:kubernetes-object-definition} eine nicht vollständige \textit{Manifest}-Datei im \ac{yaml}-Format dar.
Die kommenden Beispiele beziehen sich auf Listing~\ref{lst:kubernetes-object-definition}.

\begin{listing}[htp]
      \begin{minted}[fontsize=\small]{yaml}
      kind: Pod
      spec: 
        priority: high
        volumes: 
          - name: secret-volume
            secret: 
              secretName: 
      metadata: 
        labels: 
        namespace:
        nonexistent:
      \end{minted}
      \caption{Kubernetes Manifest-Datei}
      \label{lst:kubernetes-object-definition}
\end{listing}

\begin{description}
      \item[Anforderung 1]{- Funktionalität für jedes Kubernetes Objekt\\}
            Die Autovervollständigung und Validierung soll dem Nutzer für jedes auf dem Cluster im Standard verfügbare Kubernetes Objekt möglich sein.
            Eine eindeutige Identifikation des Objektes, welches dabei die Felder zur Validierung und Autovervollständigung vorgibt, erfolgt über
            die Angabe des Attributes \textit{apiVersion} und des Attributes \textit{kind}. Sind diese nicht angegeben, kann das definierte Objekt nicht
            eindeutig bestimmt werden.
      \item[Anforderung 2]{- Fehlen eines Attributes bei Validierung\\}
            Der Nutzer muss darüber informiert werden, welche Attribute
            in der Datei zur vollständigen Definition fehlen. Der Definition fehlt hier \ac{zB}
            die \textit{apiVersion}. Vorausgesetzt es handelt sich um ein Pflichtattribut
      \item[Anforderung 3]{- Definition eines nicht vorhandenen Attributes bei Validierung\\}
            Gibt der Nutzer ein Attribut an, welches nicht in der Definition des Objektes enthalten ist, siehe Zeile 11, so erhält dieser eine Fehlermeldung
      \item[Anforderung 4]{- Typvalidierung eines Attributes\\}
            Ist \ac{zB} der erwartete Wert eines Attributes vom Typ ``integer'',
            so muss der Nutzer bei Eingabe einer Zeichenkette darauf hingewiesen werden. Dieser Fehler ist in Zeile 3 zu sehen.
      \item[Anforderung 5]{- Autovervollständigung von Attributen\\}
            Dem Nutzer müssen, abhängig vom Kontext, Attribute zur Autovervollständigung angeboten werden.
            Wenn der Nutzer \ac{zB} seinen Cursor in Zeile 12 am Anfang stehen hat, so wird diesem das Attribut \textit{apiVersion} angeboten.
      \item[Anforderung 6]{- Autovervollständigung von Attributwerten\\}
            Befindet sich der Nutzer mit seinem Cursor im Wertbereich eines Attributes, so sollen diesem, anhängig vom Attribut, Werte zur Autovervollständigung
            angeboten werden. Die Autovervollständigung von Attributwerten ist nur möglich, falls diese vorhanden sind.
            Befindet sich der Nutzer \ac{zB} mit seinem Cursor im Wertbereich des Attributes \textit{namespace} in Zeile 10,
            werden diesem die verfügbaren \textit{Namespaces} auf dem Kubernetes Cluster vorschlagen.
            \\
            Folgende Attribute sollen dazu Autovervollständigung mit Hilfe des \textit{Kubernetes API} erhalten:
            \textbf{namespace}, \textbf{secretName}, \textbf{apiVersion}, \textbf{kind} und \textbf{labels}
\end{description}

\section{\acs{lsp}-Client}\label{sec:lsp-client}

Wie bereits zu Beginn des Kapitels erwähnt, wird das Projekt als Erweiterung für den Quellcode-Editor \ac{vscode} entwickelt.
Der Code auf Listing~\ref{lst:client-code} stellt den Einstiegspunkt für die Erweiterung dar.
Dazu wird eine activate- und eine deactivate-Funktion benötigt. Die activate-Funktion enthält Code, der zum Start der Erweiterung ausgeführt wird.
Die deactivate-Funktion enthält Code, welcher beim Beenden der Erweiterung ausgeführt wird.
Die dargestellte activate-Funktion, siehe Zeile 5, enthält außerdem Code zum Start des \ac{lsp}-Clients.
\\
Der \ac{lsp}-Client wird mit Hilfe der Klasse ``LanguageClient'' aus dem Modul ``vscode-languageclient/node'' initialisiert, siehe Zeile 20.
Ein Objekt der Klasse enthält alle notwendigen Funktionalitäten zur Kommunikation mit einem \ac{lsp}-Server.
Zur Initialisierung wird eine Client und eine Server-Konfiguration benötigt.
\\
Die Server-Konfiguration, siehe Zeile 9, gibt an, an welcher Stelle die Implementierung des \ac{lsp}-Servers zu finden ist(Attribut ``module'').
und wie die Kommunikation zwischen \ac{lsp}-Client und Server stattfindet (Attribut ``transport'').
Die Implementierung des \ac{lsp}-Servers kann über die Verzeichnisstruktur des \ac{lsp}-Clients eingebunden werden, siehe Zeile 6, da
ein \textit{Monorepo} zur Entwicklung der Erweiterung genutzt wurde.
Bei einem \textit{Monorepo} handelt es sich um ein \textit{Repository}, das mehrere unterschiedliche Projekte enthält~\cite{monorepo-narwhal}.
Der Vorteil des \textit{Monorepo} besteht im Rahmen des Projektes darin, dass der Client immer mit der aktuellen Version des Servers arbeitet.
Würde sich dieser in einem eigenen Projekt befinden, so müsste dieser mittels \ac{npm} installiert werden und bei jeder Änderung am Server auf
die neueste Version aktualisiert werden.
Die Kommunikation zwischen \ac{lsp}-Client und Server findet mittels \text{ipc} statt. Dabei handelt es sich um ein Modul von \textit{NodeJS}
zur Interprozesskommunikation. Damit können zwei \textit{NodeJS}-Prozesse, in dem Fall \acs{lsp}-Client und Server, miteinander kommunizieren.
\\
Die Client-Konfiguration, siehe Zeile 13, gibt an für welche Dateien der \ac{lsp}-Server registriert wird. Außerdem wird in Zeile 15 definiert,
für welche Dateien der \ac{lsp}-Server über Änderungen informiert wird.
\\
Der \ac{lsp}-Client wird mit der Anweisung in Zeile 24 gestartet. Der Start des \ac{lsp}-Servers benötigt keine weitere Anweisung.
Dieser wird gestartet, sobald eine \ac{yaml}-Datei geöffnet wird.

\begin{listing}[htp]
      \begin{minted}[fontsize=\footnotesize]{js}
//...
import { LanguageClient, /*...*/ } from 'vscode-languageclient/node';
let client: LanguageClient;
      
export function activate(context: ExtensionContext) {
  const serverModule = context.asAbsolutePath(path.join('server', 'out', 'server.js'));
    //...
  const serverOptions: ServerOptions = {
    run: { module: serverModule, transport: TransportKind.ipc },
    //...
  };
  const clientOptions: LanguageClientOptions = {
    documentSelector: [{ language: 'yaml' }, { pattern: '*.y(a)ml' }],
    synchronize: {
        fileEvents: [workspace.createFileSystemWatcher('**/*.y?(a)ml')]
    }
  };
  client = new LanguageClient(
      //...
      serverOptions,
      clientOptions
  );
  //...
  client.start().catch((reason) => {
      //...
  });
}
//...
      \end{minted}
      \caption{Auszug Implementierung des \acs{lsp}-Clients}
      \label{lst:client-code}
\end{listing}

\section{\acs{lsp}-Server}

Bei der Implementierung des \ac{lsp}-Servers wurden die Anforderungen aus Kapitel~\ref{sec:requirements} umgesetzt.
Der \acs{lsp}-Client stellt lediglich die Anfragen zur Autovervollständigung und Validierung und der Server enthält die Logiken,
um diese Anfragen zu beantworten.
Bevor die Anforderungen umgesetzt wurden, wurde zunächst das Kubernetes Cluster
mit Hilfe von \textit{Docker for Desktop} bereitgestellt. Mit der Bereitstellung des Clusters wird außerdem
ein \textit{kubectl}-Client installiert, der den Zugriff auf das Cluster ermöglicht.

\subsection{Erstellen von \acs{json}-Schema Dateien}

Um die Struktur der \textit{Manifest}-Dateien vorzugeben, bietet sich das in Kapitel~\ref{sec:json-schema} eingeführte \acs{json}-Schema an.
Damit lässt sich vorgeben, welche Attribute vorhanden sind, welche Attribute angegeben werden müssen und welche Typen diese haben.
Es wäre demnach möglich für alle Kubernetes Objekte händisch ein \acs{json}-Schema zu schreiben. Dies würde jedoch viel Zeit in Anspruch nehmen und
könnte bei neuen Kubernetes-Versionen mit Änderungen, die die Struktur und Syntax von \textit{Manifest}-Dateien betreffen, wieder zu einem hohen Aufwand führen.
\\
Stattdessen bietet die \textit{KubernetesAPI} die Möglichkeit den Aufbau der \textit{Manifest}-Dateien mit Hilfe der \textit{OpenAPI}-Spezifikation abzuleiten.
\\
Bei \textit{OpenAPI} handelt es sich um einen Standard zur Beschreibung von Anwendungsschnittstellen, auch~\ac{apis} genannt. Die Beschreibung der \acs{api} ist
unabhängig von einer Programmiersprache und wird im \ac{json}- oder \ac{yaml}-Format zur Verfügung gestellt~\cite{openapi-org}.
Die \textit{KubernetesAPI} stellt die \textit{OpenAPI}-Spezifikation im \ac{json}-Format bereit und diese kann anschließend durch einen Konverter in
mehrere Dateien umgewandelt werden, sodass diese jeweils ein \acs{json}-Schema eines Kubernetes Objektes enthalten.
\\
Zum Erstellen der \acs{json}-Schema Dateien wurde wie folgt vorgegangen:

\begin{description}
      \item[1. KubernetesAPI mittels Proxy zugänglich machen]
            Bevor der Konverter auf die \textit{OpenAPI}-Spezifikation des Kubernetes Clusters zugreifen kann, muss die \textit{KubernetesAPI}
            für HTTP-Aufrufe ohne Nutzung von \textit{kubectl} verfügbar gemacht werden. Dies wird mit einem \textit{Proxy} erreicht, der über die \textit{kubectl}
            bereitgestellt werden kann. \\
            Ein \textit{Proxy} ist ein Vermittler zwischen zwei Netzwerken~\cite{proxy-ryte-wiki,proxy-it-service-network}.
            Für das Projekt macht der \textit{Proxy} die \textit{KubernetesAPI} über die lokale \acs{ip}-Adresse des Rechners erreichbar.
            Dazu wird folgende Anweisung verwendet:
            \begin{minted}[linenos=false]{console}
                  kubectl proxy
            \end{minted}
      \item[2. Installieren des Konverters]
            Der ausgewählte Konverter ist in Python implementiert. Um den Konverter auszuführen wird daher ein Python-Interpreter benötigt.
            Um den Konverter als Kommandozeilentool zu nutzen muss außerdem das Paketverwaltungsprogramm \textit{pip} installiert sein.
            Der Konverter kann dann über folgende Anweisung installiert werden~\cite{openapi-to-json-schema}:
            \begin{minted}[linenos=false]{console}
                  pip install openapi2jsonschema
            \end{minted}
      \item[3. Umwandlung der \textit{OpenAPI}-Spezifikation in JSON-Schema Dateien]
            Die \textit{OpenAPI}\\-Spezifikation kann nach Ausführung der vorherigen Schritte mit folgender Anweisung umgewandelt werden:
            \begin{minted}[linenos=false, breaklines]{console}
                  openapi2jsonschema -o path/to/output/directory --kubernetes http://localhost:8001/openapi/v2
            \end{minted}
            Der Parameter ``-o'' gibt an, in welchem Verzeichnis die \ac{json}-Schema-Dateien abgelegt werden sollen.
            Mit dem Parameter ``--kubernetes'' werden zusätzliche Informationen über das betreffende Kubernetes Objekt als Attribut im \ac{json}-Schema gespeichert.
            Die angegebene \ac{url} führt zur \textit{OpenAPI}\\-Spezifikation.
\end{description}

Die generierten \ac{json}-Schema Dateien ermöglichen das Erfüllen von \textbf{Anforderung 1} aus Kapitel~\ref{sec:requirements}.

\subsection{Konzeption}

Im nächsten Schritt wurde ein Modul für \textit{NodeJS} gesucht, mit dem eine \ac{yaml}-Datei mit Hilfe eines \ac{json}-Schemas validieren
und autovervollständigen kann. Es wurde das Modul ``vscode-json-languageservice'' ausgewählt, dass von Microsoft im Editor \ac{vscode} verwendet
wird. Das gewählte Modul kann allerdings nur eine \ac{json}-Datei anhand eines \ac{json}-Schemas validieren
und autovervollständigen. Um die Funktionalitäten für \ac{yaml}-Dateien zu ermöglichen, waren grundlegende Änderungen an dem Modul nötig.
Der Code des Moduls wurde als Grundlage für die Implementierung der Sprachunterstützung genutzt.
Das Modul stellt ein \textit{Interface} bereit, welches einen Überblick über die Funktionalitäten gibt und aufzeigt, welche Änderungen
nötig sind, um diese für \ac{yaml}-Dateien zu nutzen.
\\
Abbildung~\ref{fig:language-service-interface-defition-excerpt} zeigt einen Auszug, der für die Implementierung
der Funktionalität bei \ac{yaml}-Dateien relevanten, Methoden des \textit{Interface} ``LanguageService''.
Die vollständige Definition \textit{Interface} befindet sich im Anhang auf Abbildung \ref{fig:language-service-interface-defition}.
Es folgt eine Beschreibung der einzelnen Methoden~\cite{vscode-json-language-service}:

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
      \centering
      \includesvg[width=0.75\textwidth]{images/language-service-interface-excerpt.svg} % width immer angeben!
      \caption{Auszug des Klassendiagramms des \textit{Interface} ``LanguageService''}
      \label{fig:language-service-interface-defition-excerpt}
\end{figure}


\begin{description}
      \item[parseJSONDocument]
            Parst eine \ac{json}-Datei speichert den Inhalt in einem Objekt der Klasse \textit{JSONDocument}.
            Der Parameter der Klasse \textit{TextDocument} enthält den Inhalt einer Datei, welcher durch den \ac{lsp}-Client an den \ac{lsp}-Server gesendet wird.
      \item[doComplete]
            Ermöglicht die Autovervollständigung einer \ac{json}-Datei mit einem \ac{json}-Schema. Das betreffende \ac{json}-Schema wird bei der
            Initialisierung des ``LanguageService'' übergeben.
            Als Parameter werden ein Objekt der Klasse \textit{TextDocument}, ein Objekt der Klasse \textit{JSONDocument} und ein Objekt
            des Typs \textit{Position} benötigt, welches die Zeile und Spalte angibt, in dem sich der Cursor des Nutzers befindet.
            Die Methode liefert als Ergebnis eine Liste von Elementen zur Autovervollständigung, falls vorhanden.
      \item[doValidation] Ermöglicht die Validierung einer \ac{json}-Datei mit einem \ac{json}-Schema.
            Als Parameter werden ein Objekt der Klasse \textit{TextDocument}, ein Objekt der Klasse \textit{JSONDocument} benötigt.
            Die Methode liefert als Ergebnis einen Array mit Fehlern, die bei der Validierung gefunden wurden.
            Dabei werden Fehler bei der Validierung mittels \ac{json}-Schema und Syntaxfehler zurückgegeben.
\end{description}

Die Methoden zur Validierung und Autovervollständigung benötigten jeweils ein Objekt der Klasse \textit{JSONDocument}, welches durch das Parsen einer
\ac{json}-Datei erzeugt wird.
Der Aufbau der Klasse \textit{JSONDocument} wurde als Nächstes analysiert, um festzustellen, welche Anforderungen der Parser einer \ac{yaml}-Datei
erfüllen muss, damit mit den Ergebnissen des Parsers ein Objekt erzeugt werden kann.

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
      \centering
      \includesvg[width=0.3\textwidth]{images/class-diagram-json-document-excerpt.svg} % width immer angeben!
      \caption{Auszug des Klassendiagramms der Klasse ``JSONDocument''}
      \label{fig:class-diagram-json-document-excerpt}
\end{figure}

Aus dem Auszug des Klassendiagramms auf Abbildung~\ref{fig:class-diagram-json-document-excerpt} können die Anforderungen an
den Parser aus den Attributen der Klasse abgeleitet werden:
\begin{description}
      \setlength\itemsep{-0.5cm}
      \item[root]
            In dem Attribut wird eine Baumstruktur des Aufbaus einer \ac{json}-Datei gespeichert. Der Parser muss demnach auch einen \ac{ast} erzeugen können,
            der sich in die von der Klasse ``ASTNode'' vorgegebene Struktur konvertieren lässt.
      \item[syntaxErrors] Der Parser muss Syntaxfehler erkennen und speichern.
      \item[comments] Kommentare müssen durch den Parser erkannt und gespeichert werden.
\end{description}

Aufgrund der Anforderungen wurde das Modul ``yaml'' für \textit{NodeJS} ausgewählt. Das Modul erzeugt einen \ac{ast} und parst Syntaxfehler und Kommentare.
Die interne Darstellung des \ac{ast} weicht jedoch von dem \ac{ast}, welcher in der Klasse \textit{JSONDocument} als Attribut \textit{root}
gespeichert wird, ab und muss daher konvertiert werden.
\\
Aus dem erlangten Wissen aus diesem Abschnitt und den Anforderungen aus Abschnitt~\ref{sec:requirements} wurde ein Klassendiagramm erstellt.
Das vollständige Klassendiagramm befindet sich im Anhang auf Abbildung~\ref{fig:class-diagram-lsp-Server}.
In den kommenden Abschnitten wird das gesamte Klassendiagramm mit Auszügen erläutert.

\subsection{Kommunikation mit dem \acs{lsp}-Client}

In Abschnitt~\ref{sec:lsp-client} wurde bereits gezeigt, dass der Client angibt, wie der \ac{lsp}-Server zu erreichen ist.
Die Implementierung des Einstiegspunkts des \ac{lsp}-Servers wird auf Listing~\ref{lst:server-entrypoint} dargestellt.
Dabei wurden die Module ``vscode-languageserver/node'' und ``vscode-languageserver-textdocument'' genutzt, um die
Implementierung der \ac{lsp}-Funktionalitäten zur vereinfachen.
\\
Zunächst wird ein Objekt der Klasse ``\_Connection'' erstellt mit der Funktion ``createConnection'' erstellt, siehe Zeile 10.
Die Klasse liefert Funktionalitäten zur Kommunikation mit dem \ac{lsp}-Client.
Eine Funktionalität ist \ac{zB} die Möglichkeit auf eine Anfrage zur Autovervollständigung des \ac{lsp}-Clients zu reagieren.
\\
In Zeile 11 wird der ein Objekt erstellt, dass für Verwaltung von Textdateien auf dem Server zuständig ist.
Die Textdateien sind ein Abbild der vorhandenen Textdateien, die dem Client zur Verfügung stehen.
Dieses Objekt wird im folgenden als \textit{DocumentManager} bezeichnet.
Der \textit{DocumentManager} sorgt dafür, dass bei Änderungen einer Textdatei auf der Clientseite diese auch auf dem \ac{lsp}-Server aktualisiert wird.
Zusätzlich kann über Ereignisse des \textit{DocumentManager} auf das Öffnen, Ändern und Schließen einer Textdatei reagiert werden.
\\
Das Verzeichnis, in dem sich der Server befindet, wird in der Variablen ``baseUri'', siehe Zeile 12, als absoluter Pfad gespeichert.
Der absolute Pfad wird zum Zugriff auf die \ac{json}-Schema-Dateien benötigt.
Zuletzt wird in Zeile 13 ein Objekt der Klasse ``YamlLanguageServer'' erzeugt.

\begin{listing}[htp]
      \begin{minted}[fontsize=\footnotesize]{js}
import { 
  createConnection, 
  TextDocuments, 
  //...
} from 'vscode-languageserver/node';
import { TextDocument } from 'vscode-languageserver-textdocument';
import { YamlLanguageServer } from './yamlLanguageServer';
import path from 'path';
//...
const connection = createConnection(/*...*/);
const documentManager: TextDocuments<TextDocument> = new TextDocuments(TextDocument);
const baseUri = path.resolve(__dirname, '../');
new YamlLanguageServer(connection, documentManager, baseUri);
      \end{minted}
      \caption{Auszug Implementierung des Einstiegspunkts des \acs{lsp}-Servers}
      \label{lst:server-entrypoint}
\end{listing}


Die Klasse ``YamlLanguageServer'' ist eine Kommunikationsschnittstelle zum \ac{lsp}-Client.
Einen Überblick über die Implementierung der Klasse liefert Listing~\ref{lst:server-entrypoint}.
In Zeile 6 wird ein Objekt der Klasse ``ConfigurationService'' erzeugt. Das Objekt kümmert sich
mit Hilfe von Methoden der ``\_Connection''-Klasse um die Initialisierung der Verbindung mit dem \ac{lsp}-Client.
\\
Die ``onCompletion''-Methode enthält die Logik zur Autovervollständigung. Diese wird bei einer Client-Anfrage
aufgerufen, siehe Zeile 8.
\\
Bei Änderungen an einer Textdatei wird der \textit{DocumentManager} benachrichtigt und die geänderte Datei
wird durch die ``validateTextDocument''-Methode validiert, siehe Zeile 10 und 11.
\\
Die Autovervollständigung und Validierung, die in den Methoden erfolgt, wird durch eine weitere Klasse, ``YamlLanguageService'', koordiniert.

\begin{listing}[htp]
      \begin{minted}[fontsize=\footnotesize]{js}
public constructor(
  private connection: _Connection,
  private documentManager: TextDocuments<TextDocument>,
  private baseUri: string
) {
    new ConfigurationService(connection);
    //...
    this.connection.onCompletion(this.onCompletion.bind(this));
    //...
    this.documentManager.onDidChangeContent((change) => {
        this.validateTextDocument(change.document);
    });
    //...
  }
      \end{minted}
      \caption{Auszug Implementierung des Konstruktors der Klasse ``YamlLanguageServer''}
      \label{lst:server-entrypoint}
\end{listing}

\subsection{Parsen von \acs{yaml}-Dateien}

Bevor eine Autovervollständigung oder eine Validierung einer Datei stattfinden kann, muss die \ac{yaml}-Datei geparst und
der \ac{ast} in die von der Klasse ``ASTNode'' vorgegebene Struktur umgewandelt werden.
Abbildung~\ref{fig:class-diagram-yaml-language-service-parser} stellt die beteiligten Klassen, mit wichtigen Methoden und Attributen,
beim Parsen einer \ac{yaml}-Datei dar.

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
      \centering
      \includesvg[width=1.0\textwidth]{images/class-diagram-yaml-language-service-parser.svg} % width immer angeben!
      \caption{Auszug des Klassendiagramms der benötigten Klassen zum Parsen}
      \label{fig:class-diagram-yaml-language-service-parser}
\end{figure}

Das Parsen einer \ac{yaml}-Datei beginnt mit dem Aufruf der ``parseYamlDocument''-Methode der Klasse ``YamlLanguageService''.
Dieser Methode wird die Textdatei, welche geparst werden soll übergeben. Innerhalb der Methode erfolgt ein Aufruf
der Methode ``parse'' der Klasse ``YamlParser''.
\\
Listing~\ref{lst:parse-yaml-parser} zeigt einen Auszug des Quellcodes der ``parse''-Methode der Klasse ``YamlParser''.
\\
Die Methode nimmt eine Textdatei entgegen und liefert einen Array von Objekten der Klasse ``YamlDocument'' zurück.
Mit dem Objekt der Klasse ``Parser'' werden mit einer lexikalischen Analyse \textit{Token} erzeugt, siehe Zeile 5 bis 7.
Anschließend wird jeweils eine Menge von \textit{Token} zu einem \ac{yaml}-Document zusammengefasst.
Dies geschieht in Zeile 10 und 11 mit einem Objekt der Klasse ``Composer''.
Dabei wird eine syntaktische Analyse durchgeführt. Die Variable ``documents'' enthält damit einen Array
von Objekten die Syntaxfehler und einen \ac{ast} bereitstellen.
Die Syntaxfehler werden in Zeile 15 ausgelesen und gespeichert.
Der \ac{ast} wird in Zeile 23 mittels ``convert''-Methode der Klasse ``AstConverter'' umgewandelt.
Dieser befindet sich somit im richtigen Format für die weitere Verarbeitung.
Zuletzt werden in Zeile 31 die Kommentare aus der Menge von \textit{Token} ausgelesen und dem jeweiligen ``YamlDocument''-Objekt zugeordnet.

\newpage
\begin{listing}[htp]
      \begin{minted}[fontsize=\footnotesize]{js}
public parse(textDocument: TextDocument): YamlDocument[] {
    this.yamlDocuments = [];
    const text = textDocument.getText();  
    //...
    const parser = /*...*/ new Parser() /*...*/;
    const parsedTokens = parser.parse(text);
    const tokens: CST.Token[] = Array.from(parsedTokens);
    let syntaxErrorDiagnostics: Diagnostic[];
    //...  
    const composer = new Composer(/*...*/);
    const documents = composer.compose(tokens, true, text.length);
    for (const document of documents) {
      //...
      syntaxErrorDiagnostics = [];
      for (const error of document.errors) {
        syntaxErrorDiagnostics.push(
            //...
        );
      }
      //...
      if (document.contents) {
        const astConverter = new AstConverter();
        const astNode = astConverter.convert(document.contents, /*...*/);
        const yamlDocument = 
          new YamlDocument(astNode, textDocument, syntaxErrorDiagnostics);
        //...   
        this.yamlDocuments.push(yamlDocument);
      }
    }
    //...          
    this.parseCommentsFromTokens(textDocument, tokens);
    return this.yamlDocuments;
  }
      \end{minted}
      \caption{Auszug Quellcode ``parse''-Methode der Klasse ``YamlParser''}
      \label{lst:parse-yaml-parser}
\end{listing}

Für die Implementierung der ``convert''-Methode der Klasse ``AstConverter'' wurde der Aufbau des \ac{ast} des genutzten Parsers für
die Dateien im \ac{yaml}-Format und der Aufbau des \ac{ast} des Parsers für die \ac{json}-Dateien verglichen.
Es wurde eine Zuordnungstabelle angelegt, um die Konvertierung zu implementieren.
Diese Zuordnungstabelle ist auf Tabelle~\ref{tbl:yaml-ast-to-json-ast-convert} zu seehen.
Die Tabelle zeigt außerdem eine Zuordnung der Objekttypen der beiden Formate.
Der Quellcode der Implementierung der  ``convert''-Methode befindet sich im Anhang.

\begin{table}[htp]
      \centering
      \begin{tabular}{|l|l|l|l|}
            \hline
            \acs{yaml}-Objekttyp   & Klasse \acs{yaml}-\acs{ast} & \acs{json}-Objekttyp   & Klasse \acs{json}-\acs{ast} \\
            \hline
            \hline
            Sequence               & YamlSeq                     & Array                  & ArrayAstImpl                \\
            \hline
            Mapping                & YamlMap                     & Object                 & ObjectAstImpl               \\
            \hline
            Pair                   & Pair                        & Property               & PropertyAstImpl             \\
            \hline
            \multirow{4}{*}{Value} & \multirow{4}{*}{Scalar}     & \multirow{4}{*}{Value} & StringAstImpl               \\
                                   &                             &                        & NumberAstImpl               \\
                                   &                             &                        & BooleanAstImpl              \\
                                   &                             &                        & NullAstImpl                 \\
            \hline
            Key                    & Scalar                      & Key                    & StringAstImpl               \\
            \hline
      \end{tabular}
      \caption{Zuordnungstabelle der Klassen der verschiedenen \acs{ast}-Implementierungen}
      \label{tbl:yaml-ast-to-json-ast-convert}
\end{table}

\subsection{Validierung von mit Hilfe des \acs{json}-Schemas}

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
      \centering
      \includesvg[width=1.0\textwidth]{images/class-diagram-yaml-language-service-validation.svg} % width immer angeben!
      \caption{Auszug des Klassendiagramms der benötigten Klassen zur Validierung}
      \label{fig:class-diagram-yaml-language-service-validation}
\end{figure}

\subsection{Autovervollständigung mit Hilfe des \acs{json}-Schemas}

\subsection{Autovervollständigung mit Hilfe der Kubernetes-\acs{api}}

