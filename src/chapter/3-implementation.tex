\chapter{Implementierung}\label{ch:implementation}

Um die in Kapitel~\ref{ch:introduction} gestellten Forschungsfragen zu beantworten, wurde ein \ac{lsp}-Server und ein \ac{lsp}-Client entwickelt,
welche die Autovervollständigung und Validierung von Kubernetes \textit{Manifest}-Dateien ermöglichen.
Die beiden Komponenten wurden als installierbare Erweiterung für den Quellcode-Editor \ac{vscode} bereitgestellt.

\section{Technologien}

\begin{description}
      \item[NodeJS]
            Bei \textit{NodeJS} handelt es sich um eine plattformübergreifende Laufzeitumgebung, mit welcher Javascript-Programme entwickelt werden können,
            die unabhängig von Host-Anwendungen, wie \ac{zB} dem Webbrowser laufen.
            Das Konzept des ``non-blocking I/O'' wird von \textit{NodeJS} für die parallele und asynchrone Ausführung von Code verwendet.
            Programme müssen dabei nicht auf die Ergebnisse einer Ein-/Ausgabe-Funktion warten,
            sondern werden über ein Ereignis über die Beendigung informiert.
            \textit{NodeJS} lässt sich mit Modulen erweitern.
            Der sogenannte \ac{npm} unterstützt den Entwickler dabei und kann Module sowie deren Abhängigkeiten suchen,
            installieren, entfernen und installieren.~\cite{node-js-dev-insider,node-js-about}.
            Im Rahmen des Projektes wurden mit Hilfe von NodeJS der \ac{lsp}-Client und \ac{lsp}-Server implementiert.
      \item[Typescript]
            \textit{Typescript} ist eine Skriptsprache, die eine syntaktische Obermenge von Javascript ist. Das heißt, dass \textit{Typescript} und Javascript
            die gleiche Syntax besitzen, Typescript jedoch noch über zusätzliche Syntax verfügt.
            \textit{Typescript} erlaubt dem Programmierer \ac{zB} die statische Typisierung von Variablen, Funktionsparametern und Rückgabetypen.
            Die Code-Qualität kann dadurch erhöht werden. Ein Compiler übersetzt \textit{Typescript}-Code in lauffähigen Javascript-Code, welcher dann von einer
            wie \ac{zB} \textit{NodeJS} ausgeführt werden kann~\cite{typescript-kinsta,typescript-doubleslash-blog}.
            Der \ac{lsp}-Client und \ac{lsp}-Server wurden mit der Skriptsprache \textit{Typescript} entwickelt.
      \item[Docker for Desktop]
            Mit \textit{Docker for Desktop} lassen sich Anwendungen in \textit{Containern} zusammenstellen, teilen und ausführen.
            Das Programm ist für Mac, Linux und Windows Umgebungen verfügbar und bietet ein \ac{gui} zur Verwaltung der \textit{Container} an~\cite{docker-for-desktop-overview}.
            \textit{Docker for Desktop} enthält außerdem ein Kubernetes-Cluster, welches lokal auf einem einzigen \textit{Node} ausgeführt wird~\cite{docker-for-desktop-kubernetes}.
            Die Kubernetes-API des Clusters wurde bei der Implementierung des \ac{lsp}-Server verwendet, um
            die bestehenden Objekte auf dem Cluster abzufragen und diese für die Autovervollständigung zu verwenden.
      \item[kubectl]
            \textit{kubectl} ist ein Kommandozeilentool, welches zum erstellen, untersuchen, aktualisieren und löschen von Kubernetes Objekten, sowie zum Ausrollen
            von Anwendungen und verwalten der Cluser-Ressourcen verwendet werden kann. Es kommuniziert dazu mit der Kubernetes-API.\@
            Bei der Entwicklung wurde \textit{kubectl} verwendet um den momentanen Zustand des Clusters abzufragen,
            um zu verifizieren, welche Objekte der \ac{lsp}-Server zurückgeben muss.
            Außerdem konnte der ``verbose''-Parameter der \textit{kubectl} verwendet, um die benötigten Anfragen an die Kubernetes-API anzeigen zu lassen.
            Diese wurden für die Implementierung des \ac{lsp}-Servers genutzt.
\end{description}

\section{Anforderungen}

Bevor mit der Implementierung begonnen wurde, wurden Anforderungen zur Autovervollständigung und Validierung festgelegt. Zur Veranschaulichung
dieser Anforderungen stellt Listing~\ref{lst:kubernetes-object-definition} eine nicht vollständige \textit{Manifest}-Datei im \ac{yaml}-Format dar.
Die kommenden Beispiele beziehen sich auf Listing~\ref{lst:kubernetes-object-definition}.

\begin{listing}[htp]
      \begin{minted}[fontsize=\small]{yaml}
      kind: Pod
      spec: 
        priority: high
        volumes: 
          - name: secret-volume
            secret: 
              secretName: 
      metadata: 
        labels: 
        namespace:
        nonexistent:
      \end{minted}
      \caption{Kubernetes Manifest-Datei}
      \label{lst:kubernetes-object-definition}
\end{listing}

\subsection{Validierung der Manifest-Dateien}

Bei der Validierung der \textit{Manifest}-Dateien muss der Nutzer über folgende Fehler bei der Eingabe informiert werden:
\begin{description}
      \setlength\itemsep{-0.5cm}
      \item[Fehlen eines Attributes] Der Nutzer muss darüber informiert werden, welche Attribute
            in der Datei zur vollständigen Definition fehlen. Der Definition fehlt hier \ac{zB}
            die \textit{apiVersion}.
      \item[Definition von nicht vorhandene Attributen] Gibt der Nutzer ein Attribut an, welches nicht in der Definition des Objektes enthalten ist, siehe Zeile 11, so erhält dieser eine Fehlermeldung
      \item[Typvalidierung eines Attributes] Ist \ac{zB} der erwartete Wert eines Attributes vom Typ ``integer'',
            so muss der Nutzer bei Eingabe einer Zeichenkette darauf hingewiesen werden. Dieser Fehler ist in Zeile 3 zu sehen.
\end{description}

\subsection{Autovervollständigung der Manifest-Dateien}

Bei der Autovervollständigung wurden folgende Anforderungen festgelegt:
\begin{description}
      \setlength\itemsep{-0.5cm}
      \item[Autovervollständigung von Attributen]
            Dem Nutzer müssen, abhängig vom Kontext, Attribute zur Autovervollständigung angeboten werden.
            Wenn der Nutzer \ac{zB} seinen Cursor in Zeile 12 am Anfang stehen hat, so wird diesem das Attribut \textit{apiVersion} angeboten.
      \item[Autovervollständigung von Attributwerten]
            Befindet sich der Nutzer mit seinem Cursor im Wertbereich eines Attributes, so sollen diesem, anhängig vom Attribut, Werte zur Autovervollständigung
            angeboten werden. Die Autovervollständigung von Attributwerten ist nur möglich, falls diese vorhanden sind.
            Befindet sich der Nutzer \ac{zB} mit seinm Cursor im Wertbereich des Attributes \textit{namespace} in Zeile 10,
            werden diesem die verfügbaren \textit{Namespaces} auf dem Kubernetes Cluster vorschlagen.
            \\
            Folgende Attribute sollen dazu Autovervollständigung mit Hilfe des \textit{Kubernetes API} erhalten:
            \textbf{namespace}, \textbf{secretName}, \textbf{apiVersion}, \textbf{kind} und \textbf{labels}
\end{description}

\section{\acs{lsp}-Client}
Wie bereits zu Beginn des Kapitels erwähnt, wird das Projekt als Erweiterung für den Quellcode-Editor \ac{vscode} entwickelt.
Der Code auf Listing~\ref{lst:client-code} stellt den Einstiegspunkt für die Erweiterung dar.
Dazu wird eine activate- und eine deactivate-Funktion benötigt. Die activate-Funktion enthält Code, der zum Start der Erweiterung ausgeführt wird.
Die deactivate-Funktion enthält Code, welcher beim Beenden der Erweiterung ausgeführt wird.
Die dargestellte activate-Funktion, siehe Zeile 5, enthält außerdem Code zum Start des \ac{lsp}-Clients.
\\
Der \ac{lsp}-Client wird mit Hilfe der Klasse ``LanguageClient'' aus dem Modul ``vscode-languageclient/node'' intialisiert, siehe Zeile 20.
Ein Objekt der Klasse enthält alle notwendigen Funktionalitäten zur Kommunikation mit einem \ac{lsp}-Server.
Zur Intialisierung wird eine Client und Server-Konfiguration benötigt.
\\
Die Server-Konfiguration, siehe Zeile 8, gibt an wo sich die Implementierung des \ac{lsp}-Servers befindet (Attribut ``module'')
und wie die Kommunikation zwischen \ac{lsp}-Client und Server stattfindet (Attribut ``transport'').
Die Implementierung des \ac{lsp}-Servers kann über die Verzeichnisstruktur des \ac{lsp}-Clients eingebunden werden, siehe Zeile 6, da
ein \textit{Monorepo} zur Entwicklung der Erweiterung genutzt wurde.
Bei einem \textit{Monorepo} handelt es sich um ein \textit{Repository}, das mehrere unterschiedliche Projekte enthält~\cite{monorepo-narwhal}.
Der Vorteil des \textit{Monorepo} besteht im Rahmen des Projektes darin, dass der Client immer mit der aktuellen Version des Servers arbeitet.
Würde sich dieser in einem eigenen Projekt befinden, so müsste dieser mittels \ac{npm} installiert werden und bei jeder Änderung am Server auf
die neueste Version aktualisiert werden.
Die Kommunikation zwischen \ac{lsp}-Client und Server findet mittels \text{ipc} statt. Dabei handelt es sich um ein Modul von \textit{NodeJS}
zur Interprozesskommunikation. Damit können zwei \textit{NodeJS}-Prozesse, in dem Fall \acs{lsp}-Client und Server, miteinander kommunizieren.
\\
Die Client-Konfiguration, siehe Zeile 14, gibt an für welche Dateien der \ac{lsp}-Server registriert wird. Außerdem wird in Zeile 16 definiert,
für welche Dateien der \ac{lsp}-Server über Änderungen informiert wird.
\\
Der \ac{lsp}-Client wird mit der Anweisung in Zeile 28 gestartet. Der Start des \ac{lsp}-Servers benötigt keine weitere Anweisung.
Dieser wird gestartet sobald eine \ac{yaml}-Datei geöffnet wird.

\begin{listing}[htp]
      \begin{minted}[fontsize=\footnotesize]{js}
//...
import { LanguageClient, /*...*/ } from 'vscode-languageclient/node';
let client: LanguageClient;
      
export function activate(context: ExtensionContext) {
  const serverModule = context.asAbsolutePath(path.join('server', 'out', 'server.js'));
    //...
  const serverOptions: ServerOptions = {
    run: { module: serverModule, transport: TransportKind.ipc },
    //...
  };

  const clientOptions: LanguageClientOptions = {
    documentSelector: [{ language: 'yaml' }, { pattern: '*.y(a)ml' }],
    synchronize: {
        fileEvents: [workspace.createFileSystemWatcher('**/*.y?(a)ml')]
    }
  };

  client = new LanguageClient(
      'yamlKubernetesCompletionClient',
      'YAML Kubernetes Completion',
      serverOptions,
      clientOptions
  );

  const outputChannel = window.createOutputChannel('YAML Kubernetes Completion');
  client.start().catch((reason) => {
      outputChannel.append(reason);
  });
}
//...
      \end{minted}
      \caption{Auszug Implementierung des \acs{lsp}-Clients}
      \label{lst:client-code}
\end{listing}

\section{\acs{lsp}-Server}

\subsection{Bereitstellung des Clusters}

\subsection{Erstellen der \acs{json}-Schema Dateien aus der OpenAPI-Spezifikation von Kubernetes}

\subsection{Umwandlung des \acs{ast}}

\subsection{Autovervollständigung mit Hilfe des \acs{json}-Schemas}

\subsection{Autovervollständigung mit Hilfe der Kubernetes-\acs{api}}

