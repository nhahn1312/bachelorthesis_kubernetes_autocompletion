\chapter{Implementierung}\label{ch:implementation}

Das vorherige Kapitel hat gezeigt, dass bestehende Implementierungen nicht alle Herausforderungen beim Schreiben von Kubernetes \textit{Manifest}-Dateien erfüllen
können. Um die fehlende Funktionalität bereitzustellen wurde eine Anwendung entwickelt,
welche die Autovervollständigung und Validierung von Kubernetes \textit{Manifest}-Dateien ermöglicht und dabei ausgewählte
Cluster-Ressourcen berücksichtigt. Dazu wurde ein \ac{lsp}-Server und ein \ac{lsp}-Client entwickelt.
Die beiden Komponenten wurden als installierbare Erweiterung für den Quellcode-Editor \ac{vscode} bereitgestellt.

\section{Technologien}

\begin{description}
  \item[NodeJS]
        Bei \textit{NodeJS} handelt es sich um eine plattformübergreifende Laufzeitumgebung, mit welcher Javascript-Programme entwickelt werden können,
        die unabhängig von Host-Anwendungen, wie z.B. dem Webbrowser laufen.
        Das Konzept des ``non-blocking I/O'' wird von \textit{NodeJS} für die parallele und asynchrone Ausführung von Code verwendet.
        Programme müssen dabei nicht auf die Ergebnisse einer Ein-/Ausgabe-Funktion warten,
        sondern werden über ein Ereignis über die Beendigung informiert.
        \textit{NodeJS} lässt sich mit Modulen erweitern.
        Der sogenannte \ac{npm} unterstützt den Entwickler dabei und kann Module sowie deren Abhängigkeiten suchen,
        installieren, entfernen und aktualisieren.~\cite{node-js-dev-insider,node-js-about}.
        Im Rahmen des Projektes wurden mit Hilfe von NodeJS der \ac{lsp}-Client und \ac{lsp}-Server implementiert.
  \item[Typescript]
        \textit{Typescript} ist eine Skriptsprache, die eine syntaktische Obermenge von Javascript ist. Das heißt, dass \textit{Typescript} und Javascript
        die gleiche Syntax besitzen, Typescript jedoch noch über zusätzliche Syntax verfügt.
        \textit{Typescript} erlaubt dem Programmierer z.B. die statische Typisierung von Variablen, Funktionsparametern und Rückgabetypen.
        Die Code-Qualität kann dadurch erhöht werden. Ein Compiler übersetzt \textit{Typescript}-Code in lauffähigen Javascript-Code, welcher dann von einer
        Laufzeitumgebung wie z.B. \textit{NodeJS} ausgeführt werden kann~\cite{typescript-kinsta,typescript-doubleslash-blog}.
        Der \ac{lsp}-Client und \ac{lsp}-Server wurden mit der Skriptsprache \textit{Typescript} entwickelt.
  \item[Docker for Desktop]
        Mit \textit{Docker for Desktop} lassen sich Anwendungen in \textit{Containern} zusammenstellen, teilen und ausführen.
        Das Programm ist für Mac, Linux und Windows Umgebungen verfügbar und bietet ein \ac{gui} zur Verwaltung der \textit{Container} an~\cite{docker-for-desktop-overview}.
        \textit{Docker for Desktop} enthält außerdem ein Kubernetes-Cluster, welches lokal auf einem einzigen \textit{Node} ausgeführt wird~\cite{docker-for-desktop-kubernetes}.
        Die Kubernetes-API des Clusters wurde bei der Implementierung des \ac{lsp}-Servers verwendet, um
        die bestehenden Objekte auf dem Cluster abzufragen und diese für die Autovervollständigung zu verwenden.
  \item[kubectl]
        \textit{kubectl} ist ein Kommandozeilentool, welches zum Erstellen, untersuchen, aktualisieren und löschen von Kubernetes Objekten, sowie zum Ausrollen
        von Anwendungen und verwalten der Cluster-Ressourcen verwendet werden kann. Es kommuniziert dazu mit der \textit{KubernetesAPI}.\@
        Bei der Entwicklung wurde \textit{kubectl} verwendet, um den momentanen Zustand des Clusters abzufragen,
        um zu verifizieren, welche Objekte der \ac{lsp}-Server zurückgeben muss.
        Außerdem konnte der ``verbose''-Parameter der \textit{kubectl} verwendet werden, um die benötigten Anfragen an die \textit{KubernetesAPI} anzeigen zu lassen.
        Diese wurden für die Implementierung des \ac{lsp}-Servers genutzt.
\end{description}

\section{Anforderungen}\label{sec:requirements}

Bevor mit der Implementierung begonnen wurde, wurden Anforderungen zur Autovervollständigung und Validierung festgelegt.
Diese Anforderungen, abgesehen von Anforderung 1, basieren auf den Testfällen für Herausforderung 4. Außerdem wurden Anforderungen zur Lösung von Herausforderung 2 definiert,
da diese von keinem der vorhandenen Lösungen vollständig erfüllt wurde.
Zur Veranschaulichung dieser Anforderungen stellt Listing~\ref{lst:kubernetes-object-definition} eine nicht vollständige \textit{Manifest}-Datei im \ac{yaml}-Format dar.
Die kommenden Beispiele beziehen sich auf Listing~\ref{lst:kubernetes-object-definition}.

\begin{listing}[htp]
  \begin{minted}[fontsize=\small]{yaml}
      kind: Pod
      spec: 
        priority: high
        volumes: 
          - name: secret-volume
            secret: 
              secretName: 
      metadata: 
        labels: 
        namespace:
        nonexistent:
      \end{minted}
  \caption{Kubernetes Manifest-Datei}
  \label{lst:kubernetes-object-definition}
\end{listing}

\begin{description}
  \item[Anforderung 1]{- Funktionalität für jedes Kubernetes Objekt\\}
        Die Autovervollständigung und Validierung von \textit{Mapping}-Schlüsseln soll dem Nutzer für jedes auf dem Cluster im Standard verfügbare Kubernetes Objekt möglich sein.
        Eine eindeutige Identifikation des Objektes, welches dabei die Felder zur Validierung und Autovervollständigung vorgibt, erfolgt über
        die Angabe des \textit{Mapping}-Schlüssels \textit{apiVersion} und des \textit{Mapping}-Schlüssels \textit{kind}. Sind diese nicht angegeben, kann das definierte Objekt nicht
        eindeutig bestimmt werden.
  \item[Anforderung 2]{- Fehlen eines Mapping-Schlüssels bei Validierung\\}
        Der Nutzer muss darüber informiert werden, welche \textit{Mapping}-Schlüssel in der Datei zur vollständigen Definition fehlen.
        Vorausgesetzt es handelt sich um einen Pflichtschlüssel.
        Der Definition fehlt hier z.B. die \textit{apiVersion}.
  \item[Anforderung 3]{- Definition eines nicht vorhandenen \textit{Mapping}-Schlüssels bei Validierung\\}
        Gibt der Nutzer ein Attribut an, welches nicht in der Definition des Objektes enthalten ist, siehe Zeile 11, so erhält dieser eine Fehlermeldung
  \item[Anforderung 4]{- Typvalidierung eines Scalars\\}
        Ist z.B. der erwartete Wert eines \textit{Scalars} vom Typ ``integer'',
        so muss der Nutzer bei Eingabe einer Zeichenkette darauf hingewiesen werden. Dieser Fehler ist in Zeile 3 zu sehen.
  \item[Anforderung 5]{- Autovervollständigung von Mapping-Schlüsseln\\}
        Dem Nutzer müssen, abhängig vom Kontext, \textit{Mapping}-Schlüssel zur Autovervollständigung angeboten werden.
        Wenn der Nutzer z.B. seinen Cursor in Zeile 12 am Anfang stehen hat, so wird diesem der Schlüssel \textit{apiVersion} angeboten.
  \item[Anforderung 6]{- Validierung von Mapping-Schlüssel Werten\\}
        Ist der Wert eines \textit{Mapping}-Schlüssels von einem Objekt auf dem Kubernetes Cluster anhängig, soll dieser mit Hilfe
        der \textit{Kubernetes API} validiert werden.
        Die Werte folgender \textit{Mapping}-Schlüssel werden validiert: \textbf{namespace}, \textbf{secretName}.
        Sie sind abhängig von den Kubernetes Objekten \textit{Secret} und \textit{Namespace}.
  \item[Anforderung 7]{- Autovervollständigung von Mapping-Schlüssel Werten\\}
        Befindet sich der Nutzer mit seinem Cursor im Wertbereich eines \textit{Mapping}-Schlüssels, so sollen diesem, abhängig vom \textit{Mapping}-Schlüssel, Werte zur Autovervollständigung
        angeboten werden. Die Autovervollständigung von Werten ist nur möglich, falls diese vorhanden sind.
        Befindet sich der Nutzer z.B. mit seinem Cursor im Wertbereich des \textit{Mapping}-Schlüssels \textit{namespace} in Zeile 10,
        werden diesem die verfügbaren \textit{Namespaces} auf dem Kubernetes-Cluster vorschlagen.
        \\
        Folgende \textit{Mapping-Schlüssel} sollen dazu Autovervollständigung mit Hilfe des \textit{Kubernetes API} erhalten:
        \textbf{namespace}, \textbf{secretName}, \textbf{apiVersion}, \textbf{kind} und \textbf{labels}.
\end{description}

Tabelle~\ref{tbl:test-cases-and-requirements} zeigt die Zuordnung der Testfälle aus Abschnitt~\ref{subsec:preparation} zu den gestellten Anforderungen an die Implementierung.
Sie verdeutlicht, dass die Anforderungen eine Erfüllung der Testfälle und damit eine Erfüllung der Herausforderungen ermöglichen soll.

\begin{table}[h]
  \centering
  \begin{tabular}{ll}
    \toprule
    \textbf{Testfall}        & \textbf{Anforderung} \\
    \midrule
    Testfall 2.1.1           & Anforderung 2        \\
    Testfall 2.1.2           & Anforderung 3        \\
    Testfall 2.1.3           & Anforderung 4        \\
    Testfall 2.2             & Anforderung 5        \\
    Testfall 4.1.1 und 4.1.2 & Anforderung 6        \\
    Testfall 4.2             & Anforderung 7        \\
    \bottomrule
  \end{tabular}
  \caption{Testfälle und die daraus resultierenden Anforderungen}
  \label{tbl:test-cases-and-requirements}
\end{table}


\section{\acs{lsp}-Client}\label{sec:lsp-client}

Wie bereits zu Beginn des Kapitels erwähnt, wird das Projekt als Erweiterung für den Quellcode-Editor \ac{vscode} entwickelt.
Der Code auf Listing~\ref{lst:client-code} stellt den Einstiegspunkt für die Erweiterung dar.
Dazu wird eine ``activate''- und eine ``deactivate''-Funktion benötigt. Die ``activate''-Funktion enthält Code, der zum Start der Erweiterung ausgeführt wird.
Die ``deactivate''-Funktion enthält Code, welcher beim Beenden der Erweiterung ausgeführt wird.
Die dargestellte ``activate''-Funktion, siehe Zeile 5, enthält außerdem Code zum Start des \ac{lsp}-Clients.
\\
Der \ac{lsp}-Client wird mit Hilfe der Klasse ``LanguageClient'' aus dem Modul ``vscode-languageclient/node'' initialisiert, siehe Zeile 20.
Ein Objekt der Klasse enthält alle notwendigen Funktionalitäten zur Kommunikation mit einem \ac{lsp}-Server.
Zur Initialisierung wird eine Client und eine Server-Konfiguration benötigt.
\\
Die Server-Konfiguration, siehe Zeile 9, gibt an, an welcher Stelle die Implementierung des \ac{lsp}-Servers zu finden ist(Attribut ``module'').
Sie definiert außerdem wie die Kommunikation zwischen \ac{lsp}-Client und Server stattfindet (Attribut ``transport'').
Die Implementierung des \ac{lsp}-Servers kann über die Verzeichnisstruktur des \ac{lsp}-Clients eingebunden werden, siehe Zeile 6, da
ein \textit{Monorepo} zur Entwicklung der Erweiterung genutzt wurde.
Bei einem \textit{Monorepo} handelt es sich um ein \textit{Repository}, das mehrere unterschiedliche Projekte enthält~\cite{monorepo-narwhal}.
Der Vorteil des \textit{Monorepo} besteht im Rahmen des Projektes darin, dass der Client stets mit der aktuellen Version des Servers arbeitet.
Würde sich dieser in einem eigenen \textit{Repository} befinden, so müsste dieser mittels \ac{npm} installiert werden und bei jeder Änderung am Server auf
die neueste Version aktualisiert werden.
Die Kommunikation zwischen \ac{lsp}-Client und Server findet mittels \text{ipc} statt. Dabei handelt es sich um ein Modul von \textit{NodeJS}
zur Interprozesskommunikation. Damit können zwei \textit{NodeJS}-Prozesse, in dem Fall \acs{lsp}-Client und Server, miteinander kommunizieren.
\\
Die Client-Konfiguration, siehe Zeile 13, gibt an für welche Dateien der \ac{lsp}-Server registriert wird. Außerdem wird in Zeile 15 definiert,
für welche Dateien der \ac{lsp}-Server über Änderungen informiert wird.
\\
Der \ac{lsp}-Client wird mit der Anweisung in Zeile 24 gestartet. Der Start des \ac{lsp}-Servers benötigt keine weitere Anweisung.
Dieser wird gestartet, sobald eine \ac{yaml}-Datei geöffnet wird.

\begin{listing}[htp]
  \begin{minted}[fontsize=\footnotesize]{js}
//...
import { LanguageClient, /*...*/ } from 'vscode-languageclient/node';
let client: LanguageClient;
      
export function activate(context: ExtensionContext) {
  const serverModule = context.asAbsolutePath(path.join('server', 'out', 'server.js'));
    //...
  const serverOptions: ServerOptions = {
    run: { module: serverModule, transport: TransportKind.ipc },
    //...
  };
  const clientOptions: LanguageClientOptions = {
    documentSelector: [{ language: 'yaml' }, { pattern: '*.y?(a)ml' }],
    synchronize: {
        fileEvents: [workspace.createFileSystemWatcher('**/*.y?(a)ml')]
    }
  };
  client = new LanguageClient(
      //...
      serverOptions,
      clientOptions
  );
  //...
  client.start().catch((reason) => {
      //...
  });
}
//...
      \end{minted}
  \caption{Auszug Implementierung des \acs{lsp}-Clients}
  \label{lst:client-code}
\end{listing}

\section{\acs{lsp}-Server}

Bei der Implementierung des \ac{lsp}-Servers wurden die Anforderungen aus Kapitel~\ref{sec:requirements} umgesetzt.
Der \acs{lsp}-Client stellt lediglich die Anfragen zur Autovervollständigung und Validierung und der Server enthält die Logiken,
um diese Anfragen zu beantworten.
Bevor die Anforderungen umgesetzt wurden, wurde zunächst das Kubernetes Cluster
mit Hilfe von \textit{Docker for Desktop} bereitgestellt. Mit der Bereitstellung des Clusters wird außerdem
ein \textit{kubectl}-Client installiert, der den Zugriff auf das Cluster ermöglicht.

\subsection{Erstellen von \acs{json}-Schema Dateien}

Um die Struktur der \textit{Manifest}-Dateien vorzugeben, bietet sich das in Kapitel~\ref{sec:json-schema} eingeführte \acs{json}-Schema an.
Damit lässt sich vorgeben, welche Attribute vorhanden sind, welche Attribute angegeben werden müssen und welche Typen diese haben.
Es wäre demnach möglich für alle Kubernetes Objekte händisch ein \acs{json}-Schema zu schreiben. Dies würde jedoch viel Zeit in Anspruch nehmen und
könnte bei neuen Kubernetes-Versionen mit Änderungen, die die Struktur und Syntax von \textit{Manifest}-Dateien betreffen, wieder zu einem hohen Aufwand führen.
\\
Stattdessen bietet die \textit{KubernetesAPI} die Möglichkeit den Aufbau der \textit{Manifest}-Dateien mit Hilfe der \textit{OpenAPI}-Spezifikation abzuleiten.
\\
Bei \textit{OpenAPI} handelt es sich um einen Standard zur Beschreibung von Anwendungsschnittstellen, welche auch \ac{api} genannt werden. Die Beschreibung der \acs{api} ist
unabhängig von einer Programmiersprache und wird im \ac{json}- oder \ac{yaml}-Format zur Verfügung gestellt~\cite{openapi-org}.
Die \textit{KubernetesAPI} stellt die \textit{OpenAPI}-Spezifikation im \ac{json}-Format bereit und diese kann anschließend durch einen Konverter in
mehrere Dateien umgewandelt werden, sodass diese jeweils ein \acs{json}-Schema eines Kubernetes Objektes enthalten.
\\
Zum Erstellen der \acs{json}-Schema-Dateien wurde wie folgt vorgegangen:

\begin{description}
  \item[1. KubernetesAPI mittels Proxy zugänglich machen]
        Bevor der Konverter auf die \textit{OpenAPI}-Spezifikation des Kubernetes Clusters zugreifen kann, muss die \textit{KubernetesAPI}
        für HTTP-Aufrufe ohne Nutzung von \textit{kubectl} verfügbar gemacht werden. Dies wird mit einem \textit{Proxy} erreicht, der über die \textit{kubectl}
        aktiviert werden kann. \\
        Ein \textit{Proxy} ist ein Vermittler zwischen zwei Netzwerken~\cite{proxy-ryte-wiki,proxy-it-service-network}.
        Für das Projekt macht der \textit{Proxy} die \textit{KubernetesAPI} über die lokale \acs{ip}-Adresse des Rechners erreichbar.
        Dazu wird folgende Anweisung verwendet:
        \begin{minted}[linenos=false]{console}
                  kubectl proxy
            \end{minted}
  \item[2. Installieren des Konverters]
        Der ausgewählte Konverter ist in Python implementiert. Um den Konverter auszuführen wird daher ein Python-Interpreter benötigt.
        Um den Konverter als Kommandozeilentool zu nutzen, muss außerdem das Paketverwaltungsprogramm \textit{pip} installiert sein.
        Der Konverter kann dann über folgende Anweisung installiert werden~\cite{openapi-to-json-schema}:
        \begin{minted}[linenos=false]{console}
                  pip install openapi2jsonschema
            \end{minted}
  \item[3. Umwandlung der \textit{OpenAPI}-Spezifikation in JSON-Schema Dateien]
        Die \textit{OpenAPI}\\-Spezifikation kann nach Ausführung der vorherigen Schritte mit folgender Anweisung umgewandelt werden:
        \begin{minted}[linenos=false, breaklines]{console}
                  openapi2jsonschema -o path/to/output/directory --kubernetes --strict http://localhost:8001/openapi/v2
            \end{minted}
        Der Parameter ``$-$o'' gibt an, in welchem Verzeichnis die \ac{json}-Schema-Dateien abgelegt werden sollen.
        Mit dem Parameter ``$--$kubernetes'' werden zusätzliche Informationen über das betreffende Kubernetes Objekt als Attribut im \ac{json}-Schema gespeichert.
        ``$--$strict'' ist ein Parameter, welcher angibt, dass keine nicht vorhanden \textit{Mapping}-Schlüssel bei der Definition einer Datei erlaubt sind.
        Dies wird mit einer \textit{Property} in den generierten \ac{json}-Schema-Dateien erreicht.
        Die angegebene \ac{url} führt zur \textit{OpenAPI}-Spezifikation.
\end{description}

Die generierten \ac{json}-Schema Dateien ermöglichen das Erfüllen von \textbf{Anforderung 1} aus Kapitel~\ref{sec:requirements}.

\subsection{Konzeption}

Im nächsten Schritt wurde ein Modul für \textit{NodeJS} gesucht, mit dem eine \ac{yaml}-Datei mit Hilfe eines \ac{json}-Schemas validieren
und autovervollständigen kann. Es wurde das Modul ``vscode-json-languageservice'' ausgewählt, dass von Microsoft im Editor \ac{vscode} verwendet
wird. Das gewählte Modul kann allerdings nur eine \ac{json}-Datei anhand eines \ac{json}-Schemas validieren
und autovervollständigen. Um die Funktionalitäten für \ac{yaml}-Dateien zu ermöglichen, waren grundlegende Änderungen an dem Modul nötig.
Der Code des Moduls wurde als Grundlage für die Implementierung der Sprachunterstützung genutzt.
Das Modul stellt ein \textit{Interface} bereit, welches einen Überblick über die Funktionalitäten gibt und aufzeigt, welche Änderungen
nötig sind, um diese für \ac{yaml}-Dateien zu nutzen.
\\
Abbildung~\ref{fig:language-service-interface-defition-excerpt} zeigt einen Auszug
der Methoden des \textit{Interface} ``LanguageService'',
die für die Umsetzung der Funktionalität für \ac{yaml}-Dateien relevant sind.
Die vollständige Definition des \textit{Interface} befindet sich im Anhang auf Abbildung \ref{fig:language-service-interface-defition}.
Es folgt eine Beschreibung der einzelnen Methoden~\cite{vscode-json-language-service}:

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
  \centering
  \includesvg[width=0.75\textwidth]{images/language-service-interface-excerpt.svg} % width immer angeben!
  \caption{Auszug des Klassendiagramms des \textit{Interface} ``LanguageService''}
  \label{fig:language-service-interface-defition-excerpt}
\end{figure}


\begin{description}
  \item[parseJSONDocument]
        Parst eine \ac{json}-Datei speichert den Inhalt in einem Objekt der Klasse \textit{JSONDocument}.
        Der Parameter der Klasse \textit{TextDocument} enthält den Inhalt einer Datei, welcher durch den \ac{lsp}-Client an den \ac{lsp}-Server gesendet wird.
  \item[doComplete]
        Ermöglicht die Autovervollständigung einer \ac{json}-Datei mit einem \ac{json}-Schema. Das betreffende \ac{json}-Schema wird bei der
        Initialisierung des ``LanguageService'' übergeben.
        Als Parameter werden ein Objekt der Klasse \textit{TextDocument}, ein Objekt der Klasse \textit{JSONDocument} und ein Objekt
        des Typs \textit{Position} benötigt, welches die Zeile und Spalte angibt, in dem sich der Cursor des Nutzers befindet.
        Die Methode liefert als Ergebnis eine Liste von Elementen zur Autovervollständigung, falls vorhanden.
  \item[doValidation] Ermöglicht die Validierung einer \ac{json}-Datei mit einem \ac{json}-Schema.
        Als Parameter werden ein Objekt der Klasse \textit{TextDocument}, ein Objekt der Klasse \textit{JSONDocument} benötigt.
        Die Methode liefert als Ergebnis einen Array mit Fehlern, die bei der Validierung gefunden wurden.
        Dabei werden Fehler bei der Validierung mittels \ac{json}-Schema und Syntaxfehler zurückgegeben.
\end{description}

Die Methoden zur Validierung und Autovervollständigung benötigten jeweils ein Objekt der Klasse \textit{JSONDocument}, welches durch das Parsen einer
\ac{json}-Datei erzeugt wird.
Der Aufbau der Klasse \textit{JSONDocument} wurde als Nächstes analysiert, um festzustellen, welche Anforderungen der Parser einer \ac{yaml}-Datei
erfüllen muss, damit mit den Ergebnissen des Parsers ein Objekt erzeugt werden kann.

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
  \centering
  \includesvg[width=0.3\textwidth]{images/class-diagram-json-document-excerpt.svg} % width immer angeben!
  \caption{Auszug des Klassendiagramms der Klasse ``JSONDocument''}
  \label{fig:class-diagram-json-document-excerpt}
\end{figure}

Aus dem Auszug des Klassendiagramms auf Abbildung~\ref{fig:class-diagram-json-document-excerpt} können die Anforderungen an
den Parser aus den Attributen der Klasse abgeleitet werden:
\begin{description}
  \setlength\itemsep{-0.5cm}
  \item[root]
        In dem Attribut wird eine Baumstruktur des Aufbaus einer \ac{json}-Datei gespeichert. Der Parser muss demnach auch einen \ac{ast} erzeugen können,
        der sich in die von der Klasse ``ASTNode'' vorgegebene Struktur konvertieren lässt.
  \item[syntaxErrors] Der Parser muss Syntaxfehler erkennen und speichern.
  \item[comments] Kommentare müssen durch den Parser erkannt und gespeichert werden.
\end{description}

Aufgrund der Anforderungen wurde das Modul ``yaml'' für \textit{NodeJS} ausgewählt. Das Modul erzeugt einen \ac{ast} und parst Syntaxfehler und Kommentare.
Die interne Darstellung des \ac{ast} weicht jedoch von dem \ac{ast}, welcher in der Klasse \textit{JSONDocument} als Attribut \textit{root}
gespeichert wird, ab und muss daher konvertiert werden.
\\
Aus dem erlangten Wissen aus diesem Abschnitt und den Anforderungen aus Abschnitt~\ref{sec:requirements} wurde ein Klassendiagramm erstellt.
Das vollständige Klassendiagramm befindet sich auf GitHub(\url{https://github.com/nhahn1312/bachelorthesis_kubernetes_autocompletion/blob/main/src/images/class-diagram-lsp-server.svg}).
Es enthält ausschließlich Methoden und Attribute, die zum Verständnis relevant sind.
In den kommenden Abschnitten wird das gesamte Klassendiagramm in Auszügen erläutert.

\subsection{Kommunikation mit dem \acs{lsp}-Client}\label{sec:lsp-client-communication}

In Abschnitt~\ref{sec:lsp-client} wurde bereits gezeigt, dass der Client angibt, wie der \ac{lsp}-Server zu erreichen ist.
Die Implementierung des Einstiegspunkts des \ac{lsp}-Servers ist auf Listing~\ref{lst:server-entrypoint} dargestellt.
Dabei wurden die Module ``vscode-languageserver/node'' und ``vscode-languageserver-textdocument'' genutzt, um die
Implementierung der \ac{lsp}-Funktionalitäten zur vereinfachen.
\\
Zunächst wird ein Objekt der Klasse ``\_Connection'' mit der Funktion ``createConnection'' erstellt, siehe Zeile 10.
Die Klasse liefert Funktionalitäten zur Kommunikation mit dem \ac{lsp}-Client.
Eine Funktionalität ist z.B. die Möglichkeit auf eine Anfrage zur Autovervollständigung des \ac{lsp}-Clients zu reagieren.
\\
In Zeile 11 wird ein Objekt erstellt, dass für Verwaltung von Textdateien auf dem Server zuständig ist.
Die Textdateien sind ein Abbild der vorhandenen Textdateien, die dem Client zur Verfügung stehen.
Dieses Objekt wird im folgenden als \textit{DocumentManager} bezeichnet.
Der \textit{DocumentManager} sorgt dafür, dass bei Änderungen einer Textdatei auf der Clientseite diese auch auf dem \ac{lsp}-Server aktualisiert wird.
Zusätzlich kann über Ereignisse des \textit{DocumentManager} auf das Öffnen, Ändern und Schließen einer Textdatei reagiert werden.
\\
Das Verzeichnis, in dem sich der Server befindet, wird in der Variablen ``baseUri'', siehe Zeile 12, als absoluter Pfad gespeichert.
Der absolute Pfad wird zum Zugriff auf die \ac{json}-Schema-Dateien benötigt.
Zuletzt wird in Zeile 13 ein Objekt der Klasse ``YamlLanguageServer'' erzeugt.

\begin{listing}[htp]
  \begin{minted}[fontsize=\footnotesize]{js}
import { 
  createConnection, 
  TextDocuments, 
  //...
} from 'vscode-languageserver/node';
import { TextDocument } from 'vscode-languageserver-textdocument';
import { YamlLanguageServer } from './yamlLanguageServer';
import path from 'path';
//...
const connection = createConnection(/*...*/);
const documentManager: TextDocuments<TextDocument> = new TextDocuments(TextDocument);
const baseUri = path.resolve(__dirname, '../');
new YamlLanguageServer(connection, documentManager, baseUri);
      \end{minted}
  \caption{Auszug Implementierung des Einstiegspunkts des \acs{lsp}-Servers}
  \label{lst:server-entrypoint}
\end{listing}


Die Klasse ``YamlLanguageServer'' ist eine Kommunikationsschnittstelle zum \ac{lsp}-Client.
Einen Überblick über die Implementierung der Klasse liefert Listing~\ref{lst:yaml-language-server-constructor}.
In Zeile 6 wird ein Objekt der Klasse ``ConfigurationService'' erzeugt. Das Objekt kümmert sich
mit Hilfe von Methoden der ``\_Connection''-Klasse um die Initialisierung der Verbindung mit dem \ac{lsp}-Client.
\\
Die ``onCompletion''-Methode enthält die Logik zur Autovervollständigung. Diese wird bei einer Client-Anfrage
aufgerufen, siehe Zeile 8.
\\
Bei Änderungen an einer Textdatei wird der \textit{DocumentManager} benachrichtigt und die geänderte Datei
wird durch die ``validateTextDocument''-Methode validiert, siehe Zeile 10 und 11.
\\
Die Autovervollständigung und Validierung, die in den Methoden erfolgt, wird durch eine weitere Klasse, ``YamlLanguageService'', koordiniert.

\begin{listing}[htp]
  \begin{minted}[fontsize=\footnotesize]{js}
public constructor(
  private connection: _Connection,
  private documentManager: TextDocuments<TextDocument>,
  private baseUri: string
) {
    new ConfigurationService(connection);
    //...
    this.connection.onCompletion(this.onCompletion.bind(this));
    //...
    this.documentManager.onDidChangeContent((change) => {
        this.validateTextDocument(change.document);
    });
    //...
  }
      \end{minted}
  \caption{Auszug Implementierung des Konstruktors der Klasse ``YamlLanguageServer''}
  \label{lst:yaml-language-server-constructor}
\end{listing}

\subsection{Parsen von \acs{yaml}-Dateien}

Bevor eine Autovervollständigung oder eine Validierung einer Datei stattfinden kann, muss die \ac{yaml}-Datei geparst und
der \ac{ast}, in die von der Klasse ``ASTNode'' vorgegebene Struktur, umgewandelt werden.
Abbildung~\ref{fig:class-diagram-yaml-language-service-parser} stellt die beteiligten Klassen, mit wichtigen Methoden und Attributen,
beim Parsen einer \ac{yaml}-Datei dar.

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
  \centering
  \includesvg[width=0.8\textwidth]{images/class-diagram-yaml-language-service-parser.svg} % width immer angeben!
  \caption{Auszug des Klassendiagramms der benötigten Klassen zum Parsen}
  \label{fig:class-diagram-yaml-language-service-parser}
\end{figure}

Das Parsen einer \ac{yaml}-Datei beginnt mit dem Aufruf der ``parseYamlDocument''-Methode der Klasse ``YamlLanguageService''.
Dieser Methode wird die Textdatei, welche geparst werden soll übergeben. Innerhalb der Methode erfolgt ein Aufruf
der Methode ``parse'' der Klasse ``YamlParser''.
\\
Listing~\ref{lst:parse-yaml-parser} zeigt einen Auszug des Quellcodes der ``parse''-Methode der Klasse ``YamlParser''.
\\
Die Methode nimmt eine Textdatei entgegen und liefert einen Array von Objekten der Klasse ``YamlDocument'' zurück.
\\
Mit dem Objekt der Klasse ``Parser'' werden mit einer lexikalischen Analyse \textit{Token} erzeugt, siehe Zeile 5 bis 7.
Anschließend wird jeweils die Menge von \textit{Token}, die einem \ac{yaml}-\textit{Document} zugehörig sind, zusammengefasst.
Dies geschieht in Zeile 10 und 11 mit einem Objekt der Klasse ``Composer''.
Dabei wird eine syntaktische Analyse durchgeführt. Die Variable ``documents'' enthält damit einen Array
von Objekten die Syntaxfehler und einen \ac{ast} als Attribute besitzen.
Die Syntaxfehler werden in Zeile 15 ausgelesen und gespeichert.
Der \ac{ast} wird in Zeile 23 mittels ``convert''-Methode der Klasse ``AstConverter'' umgewandelt.
Dieser befindet sich somit im richtigen Format für die weitere Verarbeitung.
Zuletzt werden in Zeile 31 die Kommentare aus der Menge von \textit{Token} ausgelesen und dem jeweiligen ``YamlDocument''-Objekt zugeordnet.

\begin{listing}[htp]
  \begin{minted}[fontsize=\footnotesize]{js}
public parse(textDocument: TextDocument): YamlDocument[] {
    this.yamlDocuments = [];
    const text = textDocument.getText();  
    //...
    const parser = /*...*/ new Parser() /*...*/;
    const parsedTokens = parser.parse(text);
    const tokens: CST.Token[] = Array.from(parsedTokens);
    let syntaxErrorDiagnostics: Diagnostic[];
    //...  
    const composer = new Composer(/*...*/);
    const documents = composer.compose(tokens, true, text.length);
    for (const document of documents) {
      //...
      syntaxErrorDiagnostics = [];
      for (const error of document.errors) {
        syntaxErrorDiagnostics.push(
            //...
        );
      }
      //...
      if (document.contents) {
        const astConverter = new AstConverter();
        const astNode = astConverter.convert(document.contents, /*...*/);
        const yamlDocument = 
          new YamlDocument(astNode, textDocument, syntaxErrorDiagnostics);
        //...   
        this.yamlDocuments.push(yamlDocument);
      }
    }
    //...          
    this.parseCommentsFromTokens(textDocument, tokens);
    return this.yamlDocuments;
  }
      \end{minted}
  \caption{Auszug Quellcode ``parse''-Methode der Klasse ``YamlParser''}
  \label{lst:parse-yaml-parser}
\end{listing}

Für die Implementierung der ``convert''-Methode der Klasse ``AstConverter'' wurde der Aufbau des \ac{ast} des genutzten Parsers für
die Dateien im \ac{yaml}-Format und der Aufbau des \ac{ast} des Parsers für die \ac{json}-Dateien verglichen.
Es wurde eine Zuordnungstabelle angelegt, um die Konvertierung zu implementieren.
Tabelle~\ref{tbl:yaml-ast-to-json-ast-convert} zeigt die Zuordnung der Objekttypen der beiden Formate zu deren Klassen der \ac{ast}-Implementierung.
Mit den Informationen aus der Tabelle wurde ein Algorithmus erstellt, der den \ac{ast} der \ac{yaml}-Datei rekursiv traversiert und konvertiert.
%Der Quellcode der Implementierung der  ``convert''-Methode befindet sich im Anhang.

\begin{table}[htp]
  \centering
  \begin{tabular}{llll}
    \toprule
    \textbf{\acs{yaml}-Objekttyp} & \begin{tabular}{@{}l@{}}\textbf{Klasse} \\ \textbf{\acs{yaml}-\acs{ast}}\end{tabular} & \textbf{\acs{json}-Objekttyp} & \begin{tabular}{@{}l@{}}\textbf{Klasse} \\ \textbf{\acs{json}-\acs{ast}}\end{tabular} \\
    \midrule
    Sequence                      & YamlSeq                                                                                                          & Array                         & ArrayAstImpl                                                                                                     \\
    \midrule
    Mapping                       & YamlMap                                                                                                          & Object                        & ObjectAstImpl                                                                                                    \\
    \midrule
    Pair                          & Pair                                                                                                             & Property                      & PropertyAstImpl                                                                                                  \\
    \midrule
    \multirow{4}{*}{Scalar}       & \multirow{4}{*}{Scalar}                                                                                          & \multirow{4}{*}{Value}        & StringAstImpl                                                                                                    \\
                                  &                                                                                                                  &                               & NumberAstImpl                                                                                                    \\
                                  &                                                                                                                  &                               & BooleanAstImpl                                                                                                   \\
                                  &                                                                                                                  &                               & NullAstImpl                                                                                                      \\
    \midrule
    Mapping-Schlüssel             & Scalar                                                                                                           & Key                           & StringAstImpl                                                                                                    \\
    \bottomrule
  \end{tabular}
  \caption{Zuordnungstabelle der Klassen der verschiedenen \acs{ast}-Implementierungen}
  \label{tbl:yaml-ast-to-json-ast-convert}
\end{table}

\subsection{Validierung}\label{subsec:validation}

Als Nächstes erfolgte die Implementierung der Validierung. Wie bereits in Abschnitt~\ref{sec:lsp-client-communication} erwähnt wird die
Validierung bei jeder Änderung an einer \ac{yaml}-Datei, die durch den Nutzer erfolgt, durchgeführt.
Vor jeder Validierung findet das Parsen der \ac{yaml}-Datei mit der im vorherigen Abschnitt erwähnten Methode ``parseYamlDocument'' statt.
Die Validierung beginnt mit dem Aufruf der Methode ``doValidation'' der Klasse ``YamlLanguageService''.
Die Methode ruft anschließend die Validierung anhand der \ac{json}-Schema-Dateien und die Validierung anhand von Objekten auf dem Kubernetes Cluster
auf. Die beiden Implementierungen werden im kommenden Abschnitt erläutert.

\textbf{Validierung anhand der \ac{json}-Schema-Dateien}

Auf Abbildung~\ref{fig:class-diagram-yaml-language-service-validation} ist ein Auszug des Klassendiagramms der beteiligten Klassen
für die Validierung mit Hilfe der \ac{json}-Schema-Dateien dargestellt.
Da die Umwandlung des \ac{ast} erfolgt ist, konnten die bereits bestehenden Klassen ``JSONValidation'' und ``JSONSchemaService''
des Moduls ``vscode-json-languageservice'' verwendet und bei Bedarf erweitert werden.

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
  \centering
  \includesvg[width=0.6\textwidth]{images/class-diagram-yaml-language-service-validation.svg} % width immer angeben!
  \caption{Auszug des Klassendiagramms der benötigten Klassen zur Validierung anhand von \ac{json}-Schema-Dateien}
  \label{fig:class-diagram-yaml-language-service-validation}
\end{figure}
Zuerst wird die Methode ``doValidation'' der Klasse ``JSONValidation'' aufgerufen.
An dieser mussten keine Änderungen durchgeführt werden. In der Methode wird mit Hilfe von einem Objekt der Klasse ``JSONSchema'' und dessen Methode ``getSchemaForResource'' ein geeignetes \ac{json}-Schema
für die zu validierende \ac{yaml}-Datei gesucht. Diese Suche wurde erweitert, sodass sie das \ac{json}-Schema anhand
der \textit{Mapping}-Schlüssel ``apiVersion'' und ``kind'' auswählt.
Ist keiner oder nur einer der \textit{Mapping}-Schlüssel vorhanden, gibt es kein eindeutiges Ergebnis, was dem Nutzer durch eine Warnung angezeigt wird.
Wird ein \ac{json}-Schema gefunden, findet anhand dessen eine Validierung statt und dem Nutzer werden mögliche Fehler angezeigt.
Da für die Validierung mittels \ac{json}-Schema die bereits vorhandenen Klassen genutzt oder erweitert wurden,
konnten damit die \textbf{Anforderungen 2}, \textbf{3} und \textbf{4} aus Abschnitt~\ref{sec:requirements} erfüllt werden.

\textbf{Validierung anhand von Kubernetes Objekten auf dem Cluster}

Bei der Validierung von Kubernetes Objekten auf dem Cluster können die \ac{json}-Schema-Dateien nicht verwendet werden.
Anhand des \ac{json}-Schemas kann nicht bestimmt werden, welches Kubernetes Objekt, welchem \textit{Mapping}-Schlüssel in der
\textit{Manifest}-Datei zugeordnet ist. Das \ac{json}-Schema bietet nicht die Möglichkeit zur Definition eigener Typen.
Der \textit{Mapping}-Schlüssel für einen \textit{Namespace} ist z.B. vom Typ ``string'' und kann ohne weitere Informationen nicht in der Datei validiert werden.
Die Lösung dafür ist eine eigene Zuordnung von \textit{Mapping}-Schlüsseln zu Kubernetes Objekten oder anderen aus dem Cluster gespeicherten Informationen anzulegen.
Die Implementierung dieser Lösung ist unabhängig von den \ac{json}-Schema-Dateien möglich.
Abbildung~\ref{fig:class-diagram-yaml-language-service-validation-kubernetes} zeigt einen Auszug der dazu benötigten Klassen.

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
  \centering
  \includesvg[width=0.85\textwidth]{images/class-diagram-yaml-language-service-validation-kubernetes.svg} % width immer angeben!
  \caption{Auszug des Klassendiagramms der benötigten Klassen zur Validierung mit KubernetesAPI}
  \label{fig:class-diagram-yaml-language-service-validation-kubernetes}
\end{figure}

Als Erstes wird die Methode ``doValidation'' der Klasse ``SchemalessValidationService'' aufgerufen.
Die Übergabeparameter sind der Inhalt der aktuellen Datei und das geparste \ac{yaml}-\textit{Document}.
Die Validierung wird mit Objekten durchgeführt, die die ``getRules''-Methode der Klasse ``RuleProvider'' zur Verfügung stellt.
Die Klassen der Objekte ordnen \textit{Mapping}-Schlüsseln aus einer \textit{Manifest}-Datei jeweils
einem Kubernetes Objekt zu.
Sie werden für die Validierung und die Autovervollständigung verwendet und werden im folgenden als Zuordnungsregeln bezeichnet.
\\
Bei der Implementierung der Zuordnungsregeln wurde ein Entwurfsmuster aus der Softwareentwicklung verwendet, welches als ``Template Method'' bezeichnet wird.
``Template Method'' ist ein sogenanntes Verhaltensmuster, welches den Aufbau eines Algorithmus in einer Basisklasse beschreibt und
die abgeleiteten Klassen spezifische Schritte des Algorithmus überschreiben lässt.
Die Basisklasse definiert dazu eine abstrakte Methode, welche als Platzhalter agiert und optional eine Standardimplementierung besitzt.
Die abgeleiteten Klassen überschreiben diese und andere Methoden, die an dem Prozess beteiligt sind, um
das Verhalten für einen spezifischen Anwendungsfall zu ändern oder zu vervollständigen~\cite{typescript-design-pattern-chapter-6,design-patterns-refactoring-guru}.
\\
Die Basisklasse ``Rule'' liefert Werte zur Validierung und Autovervollständigung mittels der Methode ``getValues''.
Sie wird von mehreren Klassen erweitert, die die benötigten Informationen vom Kubernetes Cluster bereitstellen.
Beispielhaft ist auf der Abbildung die Klasse ``SecretRule'' zu sehen, welche die verfügbaren \textit{Secrets} auf dem Kubernetes Cluster abfragt.
Es folgt eine Beschreibung der Methoden und Attribute der Klasse ``SecretRule'':
\begin{description}
  \setlength\itemsep{-0.5cm}
  \item[keys]
        Gibt an für welche \textit{Mapping}-Schlüssel die Werte für den Nutzer validiert oder autovervollständigt werden.
        Das Attribut muss von abgeleiteten Klassen überschrieben werden.
        Für die Klasse ``SecretRule'' enthält das Attribut den \textit{Mapping}-Schlüssel ``secretName''.
  \item[shouldCollectValuesFromDocuments]
        Gibt an, ob für die angegebene Menge von ``keys'' Werte aus dem aktuellen und anderen geöffneten Dateien gesammelt werden sollen.
        Das Attribut muss von abgeleiteten Klassen überschrieben werden. Dieses Attribut wird für die Autovervollständigung verwendet.
  \item[getApiCompletionValues]
        Die abstrakte Methode muss von den abgeleiteten Klassen überschrieben werden. Sie ist für die Abfrage der benötigten Werte vom Cluster zuständig.
  \item[test]
        Die abstrakte Methode muss von den abgeleiteten Klassen überschrieben werden. Mit ihr können zusätzliche Einschränkungen
        für die \textit{Mapping}-Schlüssel definiert werden. Damit kann z.B. festgelegt werden, welchen Elternknoten im \ac{ast}
        ein \textit{Mapping}-Schlüssel besitzen muss, damit der Nutzer eine Validierung oder Werte zur Autovervollständigung erhält.
  \item[isApplicable]
        Ermittelt mit Hilfe der ``test''-Methode, ob ein gegebener Knoten im \ac{ast} Werte zur Autovervollständigung oder eine Validierung benötigt.
\end{description}

Die Zuordnungsregeln nutzen die Klasse ``KubernetesApiService'' als Schnittstelle zur \textit{KubernetesAPI}.
Ein Objekt der Klasse sendet Anfragen über das \ac{https}-Protokoll zum \textit{API-Server}
des Kubernetes Clusters und verarbeitet die Antworten. Wie in \textbf{Anforderung 6} und \textbf{Anforderung 7} aus Abschnitt~\ref{sec:requirements} festgelegt,
speichert ein Objekt der Klasse ``KubernetesApiService'' die Informationen über folgende Kubernetes Objekte auf dem Cluster: \textit{Namespace} und \textit{Secret}.
Es wird zusätzlich eine Liste aller verfügbaren Objekttypen(``kind'') mit deren Version(``apiVersion'') gespeichert.
Zuletzt werden die verfügbaren \textit{Labels} des Clusters festgehalten.
Die Informationen werden in einem \textit{Cache} abgelegt und nach Ablauf einer Zeitspanne erneut vom Cluster abgefragt, siehe
Attribut ``cacheMap'' der Klasse ``KubernetesApiService''.
Die Ablaufzeit und die Zugangsdaten des Clusters können vom Nutzer über eine Einstellung in der \ac{vscode}-Erweiterung
konfiguriert werden. Diese Einstellungen sind im Attribut ``settings'' gespeichert.

\begin{listing}[htp]
  \begin{minted}[fontsize=\footnotesize]{js}
async doValidation(document: TextDocument, yamlDocument: YamlDocument)
: Promise<Diagnostic[]> {
  const applicableValueNodes: Map<ASTNode, Rule> = new Map();
  yamlDocument.visit((node: ASTNode) => {
    //...
      const key = node.keyNode.value;
      const rules = this.ruleProvider.getRules();
      for (const rule of rules) {
        if (rule.isApplicable(node, key) /*...*/) {
            const currentValueNode = node.valueNode;
            applicableValueNodes.set(currentValueNode, rule);
        }
      }
    //...
    return true;
  });
  return this.getDiagnostics(applicableValueNodes, document, yamlDocument);
}
      \end{minted}
  \caption{Auszug Quellcode ``doValidation''-Methode der Klasse ``SchemalessValidationService''}
  \label{lst:do-validation-schemaless-validation-service}
\end{listing}

Listing~\ref{lst:do-validation-schemaless-validation-service} zeigt einen Auszug der ``doValidation''-Methode der Klasse ``SchemalessValidationService''.
Es veranschaulicht, wie die Zuordnungsregeln genutzt werden, um Knoten im \ac{ast} zu finden, für die eine Validierung durchgeführt
werden muss. Dazu wird in Zeile 4 der gesamte \ac{ast} des \ac{yaml}-\textit{Documents} traversiert. Für
jeden Knoten wird überprüft, ob eine der Zuordnungsregeln für diesen anwendbar ist, siehe Zeile 8 und 9.
Ist eine Regel auf einen Knoten anwendbar, wird dieser Zusammenhang gespeichert, siehe Zeile 11. Die Abfrage der Werte von der \textit{KubernetesAPI} und
das Validieren wird in der ``getDiagnostics''-Methode, siehe Zeile 17, durchgeführt.

\subsection{Autovervollständigung}

Der Auslöser für die Autovervollständigung ist das Betätigen einer Tastenkombination auf der Clientseite. Der \ac{lsp}-Client signalisiert dem \ac{lsp}-Server,
dass eine Autovervollständigung vom Nutzer gewünscht ist und übergibt die Position des Cursors in der Datei.
Anschließend wird vom \ac{lsp}-Server die ``doComplete''-Methode des Objekts der Klasse ``YamlLanguageServer'' aufgerufen.
In der Methode wird die \ac{yaml}-Datei geparst und das \ac{yaml}-\textit{Document} gefunden, in welchem sich der Cursor befindet.
Das \ac{yaml}-\textit{Document} wird dem Inhalt der Textdatei und der Position des Cursors an die Methode ``doComplete'' des Objektes der Klasse ``YamlLanguageService'' übergeben.
Ein Ausschnitt des Quellcodes der Methode ist auf Listing~\ref{lst:do-complete-yaml-language-service} zu sehen.

\begin{listing}[htp]
  \begin{minted}[fontsize=\footnotesize]{js}
async doComplete(document: TextDocument, position: Position, doc: YamlDocument)
: Promise<CompletionList | null> 
{
  const compColl: CompletionsCollectorImpl = new CompletionsCollectorImpl();
  //...
  const offset = document.offsetAt(position);
  const node = doc.getNodeFromOffset(offset);
  const documentInfo: DocumentInfo = {
    document: document,
    yamlDocument: doc,
    position: position
  };

  await this.schemaCompletionService.doComplete(node, compColl, documentInfo);
  await this.schemaLessCompletionService.doComplete(node, compColl, documentInfo);

  return compColl.getCompletionList();
}
      \end{minted}
  \caption{Auszug Quellcode ``doComplete''-Methode der Klasse ``YamlLanguageService''}
  \label{lst:do-complete-yaml-language-service}
\end{listing}

Das Objekt der Klasse ``CompletionsCollectorImpl'' dient zum Speichern der möglichen Autovervollständigungen, siehe Zeile 3.
\\
Bevor diese gefunden werden können, muss der Kontext der Position des Cursors bestimmt werden.
Dieser wird mit der Methode ``getNodeFromPosition'' der Klasse ``YamlDocument'' bestimmt, siehe Zeile 7.
Dafür wird der Knoten im \ac{ast} gesucht, welcher den Wert enthält, den der Nutzer vervollständigen möchte.
Der gefundene Knoten könnte z.B. ein \textit{Mapping}-Schlüssel sein.
Zur Autovervollständigung würde der Nutzer mögliche Werte für den \textit{Mapping}-Schlüssel vorgeschlagen bekommen.
Ein Ablaufdiagramm der ``getNodeFromPosition''-Methode befindet sich im Anhang.
\\
Anschließend können durch die Objekte der Klassen ``SchemaCompletionService'' und ``SchemalessCompletionService''
die Vorschläge zur Autovervollständigung unter Berücksichtigung des Kontexts gesammelt werden.
Dies wird jeweils mit dem Aufruf der ``doComplete''-Methode erreicht, siehe Zeile 14 und Zeile 15.
Die Methode liefert abschließend in Zeile 17 die Vorschläge zur Autovervollständigung.

\textbf{Autovervollständigung anhand der \ac{json}-Schema-Dateien}

Das Objekt der Klasse ``SchemaCompletionService'' liefert Autovervollständigungen mit Hilfe der \ac{json}-Schema-Dateien.
Dazu wird, wie bei der Validierung, das Objekt der Klasse ``JSONSchemaService'' genutzt, um das \ac{json}-Schema für das \ac{yaml}-\textit{Document}
zu ermitteln. Die Klasse ``SchemaCompletionService'' wurde auf Grundlage der Klasse ``JSONCompletionService'' des Moduls ``vscode-json-languagservice''
entwickelt. Es wurden Anpassungen vorgenommen, die bei der Autovervollständigung aufgrund des \ac{yaml}-Formates notwendig waren.
Hier musste z.B. verhindert werden, dass bei der Vervollständigung eines \ac{json}-\textit{Keys} dieser mit Anführungszeichen eingeschlossen wurde.
Im \ac{yaml}-Format ist dies für einen \textit{Mapping}-Schlüssel nicht erlaubt.
Die Klasse ``SchemaCompletionService'' erfüllt \textbf{Anforderung 5} aus Abschnitt~\ref{sec:requirements}.

\textbf{Autovervollständigung anhand von Kubernetes Objekten auf dem Cluster}

Das Objekt der Klasse ``SchemalessCompletionService'' liefert Autovervollständigungen mit Hilfe der \textit{KubernetesAPI}.
Außerdem wird eine Autovervollständigung
mit Werten von \textit{Mapping}-Schlüssel aus dem aktuellen und anderen auf dem Client geöffneten Dokumenten,
die noch nicht auf das Cluster ausgerollt wurden, angeboten.
Damit kann z.B. ein \textit{Namespace} als Vorschlag zur Autovervollständigung angeboten werden, der noch nicht auf dem Cluster vorhanden ist,
die \textit{Manifest}-Datei zur Erstellung aber bereits angelegt wurde.
Abbildung~\ref{fig:class-diagram-yaml-language-service-schemaless-completion} zeigt einen Auszug des Klassendiagramms der dazu benötigten Klassen.

\begin{figure}[htp] % htp = hier (h), top (t), oder auf einer eigenen Seite (p).
  \centering
  \includesvg[width=1.0\textwidth]{images/class-diagram-yaml-language-service-schemaless-completion.svg} % width immer angeben!
  \caption{Auszug des Klassendiagramms der benötigten Klassen zur Autovervollständigung mit KubernetesAPI}
  \label{fig:class-diagram-yaml-language-service-schemaless-completion}
\end{figure}

Das Objekt der Klasse ``SchemalessCompletionService'' nutzt zur Autovervollständigung von Werten vom Cluster die
in Abschnitt~\ref{subsec:validation} eingeführten Zuordnungsregeln.
\\
Die ``buildCompletionCache''-Methode der Klasse ``CacheValueService'' sammelt anhand der \textit{Mapping}-Schlüssel
der Zuordnungsregeln die Werte aus der aktuellen und anderen geöffneten Dateien.
Das Attribut ``shouldCollectValuesFromDocuments'' einer Zuordnungsregel, siehe Klasse ``SecretRule'', gibt an,
ob für diese Werte gesammelt werden sollen.
Die Werte aus den beiden Quellen werden zusamengeführt und dem Nutzer zur Verfügung gestellt.
\\
Der Ausschnitt des Quellcodes der ``getCompletions''-Methode der Klasse ``SchemalessCompletionService'' veranschaulicht,
wie Zuordnungsregeln verwendet werden, um die Werte zur Autovervollständigung für den Nutzer bereitzustellen.
Der Ausschnitt des Quellcodes ist auf Listing~\ref{lst:get-completions-schemaless-completion-service} zu sehen. Die Methode wird aus der Methode ``doComplete'' der Klasse ``SchemalessCompletionService'' heraus aufgerufen.
Sie erhält als Übergabeparameter den Knoten und den \textit{Mapping}-Schlüssel, der den Wert enthält, sowie den Parameter vom Typ
``DocumentInfo''. Dieser enthält die Position des Cursors, die Textdatei und das \ac{yaml}-\textit{Document}, in dem sich die
Position des Cursors befindet. Die Variable ``rules'' in Zeile 8 enthält die Zuordnungsregeln.
Mit Hilfe der Bedingung in Zeile 10 wird überprüft, ob eine der Zuordnungsregeln im aktuellen Kontext angewendet werden kann.
Die Anweisung in Zeile 15 sorgt dafür, dass die Werte vom Kubernetes Cluster mit den gesammelten Werten
aus den geöffneten Dateien zusamengeführt werden.

\begin{listing}[t]
  \begin{minted}[fontsize=\footnotesize]{js}
private async getCompletions(
        node: ASTNode,
        key: string,
        documentInfo: DocumentInfo,
        //...
    ): Promise<CompletionItem[]> {
  let completions: CompletionItem[] = [];
  const rules = this.ruleProvider.getRules();
  for (const rule of rules) {
    if (rule.isApplicable(node, key, type)) {
      const apiCompletionValues = await rule.getValues({
        yamlDocument: documentInfo.yamlDocument,
        document: documentInfo.document
      });
      completions = [
        ...completions,
        ...apiCompletionValues,
        ...this.cacheValueService.getCachedCompletionsFromDocuments(rule)
      ];
    }
  }
  return completions;
}
      \end{minted}
  \caption{Auszug Quellcode ``getCompletions''-Methode der Klasse ``SchemalessCompletionService''}
  \label{lst:get-completions-schemaless-completion-service}
\end{listing}

\FloatBarrier

\section{Bereitstellen der \acs{vscode}-Erweiterung}

Nach Abschluss der Implementierung wurde die \acs{vscode}-Erweiterung aus dem Quellcode erstellt.
Dazu wurde das Kommandozeilentool \ac{vsce} verwendet, welches das Erstellen und Veröffentlichen von
\acs{vscode}-Erweiterungen ermöglicht. In dem Fall wurde nur die Erweiterung erstellt und als
Datei zur Verfügung gestellt.
Dazu wurde folgender Befehl im Wurzelverzeichnis des Projekts ausgeführt:
\begin{minted}[linenos=false, breaklines]{console}
      vsce package
\end{minted}
Die erstellte Datei kann anschließend auf einem System mit installiertem \ac{vscode} als
Erweiterung mit folgendem Befehl installiert werden:
\begin{minted}[linenos=false, breaklines]{console}
  code --install-extension yaml-kubernetes-completion-1.0.0.vsix
\end{minted}

%Der Nutzer kann folgende Einstellungen vornehmen, um die Anwendung
%zu konfigurieren:
%\begin{itemize}
%  \setlength\itemsep{-0.5cm}
%  \item Konfiguration der Länge der Einrückung für \ac{yaml}-Dateien, angegeben in Anzahl der Leerzeichen. Standardeinstellung sind zwei Leerzeichen.
%  \item Einstellen der Ablaufzeit des Caches für die Werte vom Kubernetes Cluster. Standardeinstellung sind 600 Sekunden.
%  \item Pfad zur Kubernetes Konfigurationsdatei, die die Login-Informationen zum Cluster enthält. Standardeinstellung ist das ``Home''-Verzeichnis des Nutzers.
%  \item Namen der Dateien für die die Autovervollständigung und Validierung im Rahmen der Anwendung ausgeführt werden sollen.
%        Hier können reguläre Ausdrücke angegeben werden. Die Standardeinstellung enthätlt nur den Dateinamen ``kubernetes.yaml''.
%\end{itemize}